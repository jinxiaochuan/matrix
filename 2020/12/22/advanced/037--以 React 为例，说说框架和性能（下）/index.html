<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶37 | 以 React 为例，说说框架和性能（下） | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React为主，分析这两个框架在设计层面，而非使用层面的性能考量。 相关知识点如下图所示：  React 性能设计亮点React 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶37 | 以 React 为例，说说框架和性能（下）">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/037--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React为主，分析这两个框架在设计层面，而非使用层面的性能考量。 相关知识点如下图所示：  React 性能设计亮点React 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:modified_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/037--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-22 20:51:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/matrix/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶37 | 以 React 为例，说说框架和性能（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-22T12:51:17.444Z" title="更新于 2020-12-22 20:51:17">2020-12-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一讲中，我们提到了框架性能优化的一些基本概念，并分析了以 React<br>框架为代表的常用优化手段。但是这些内容还不够，需要了解更多框架设计底层的性能相关话题。这一讲，我将会以 Vue（未来新版本 3.0）和 React<br>为主，分析这两个框架在设计层面，而非使用层面的性能考量。</p>
<p>相关知识点如下图所示：</p>
<p><img src="https://images.gitbook.cn/dd24aad0-cbf3-11e9-a9bd-857608719494" alt="enter image description
here"></p>
<h3 id="React-性能设计亮点"><a href="#React-性能设计亮点" class="headerlink" title="React 性能设计亮点"></a>React 性能设计亮点</h3><p>React 设计上的性能亮点非常多，除了“老生常谈”的虚拟 DOM 之外，还有很多不为人知的细节，比如事件机制（合成和池化）、React fiber 设计。</p>
<h4 id="React-性能设计亮点之事件"><a href="#React-性能设计亮点之事件" class="headerlink" title="React 性能设计亮点之事件"></a>React 性能设计亮点之事件</h4><p>React 事件机制我们前面已经有所介绍，总结一下性能亮点的体现有：</p>
<ul>
<li>将所有事件挂载到 document 节点上，利用事件代理实现优化；</li>
<li>采用合成事件，在原生事件的基础上包装合成事件，并结合池化思路实现内存保护。</li>
</ul>
<p>前面课程《第 4-2 课：你真的懂 React 吗？》已经介绍过相关内容，这里不再展开。</p>
<h4 id="React-性能设计亮点之-setState"><a href="#React-性能设计亮点之-setState" class="headerlink" title="React 性能设计亮点之 setState"></a>React 性能设计亮点之 setState</h4><p>setState 这个谜之 API 我们也有所介绍，其异步（或者叫做 batch 合并）设计也是出于性能的考虑。这种优化思路已经被很多框架所借鉴，Vue<br>当中也是有类似的设计。</p>
<h4 id="React-性能设计亮点之-React-fiber"><a href="#React-性能设计亮点之-React-fiber" class="headerlink" title="React 性能设计亮点之 React fiber"></a>React 性能设计亮点之 React fiber</h4><p>前面两个“亮点”我们在以往的课程中已经有所涉及，这里来重点说一下 React fiber。</p>
<p>通过课程《第 2-1 和 2-2 课：异步不可怕“死记硬背”+ 实战拿下》，我们知道在浏览器主线程中，JavaScript 代码在调用栈 call<br>stack 执行时，可能会调用浏览器的 APIs，对 DOM 进行操作；也可能执行一些异步任务：这些异步任务如果是以回调的方式处理，那么往往会被添加到<br>event queue 当中；如果是以 promise 处理，就会先放到 job queue<br>当中。这个涉及到宏任务和微任务，这些异步任务和渲染任务将会在下一个时序当中由调用栈处理执行。</p>
<p>理解了这些，大家就会明白：如果调用栈 call stack 运行一个很耗时的脚本，比如解析一个图片，call stack<br>就会像北京上下班高峰期的环路入口一样，被这个复杂任务堵塞。主线程其他任务都要排队，进而阻塞 UI 响应。这时候用户点击、输入、页面动画等都没有了响应。</p>
<p>这样的性能瓶颈，就如同阿喀琉斯之踵一样，在一定程度上限制着 JavaScript 的发挥。</p>
<p>我们一般有两种方案突破上文提到的瓶颈，其中之一就是将耗时高、成本高、易阻塞的长任务切片，分成子任务，并异步执行。</p>
<p>这样一来，这些子任务会在不同的 call stack tick 周期执行，进而主线程就可以在子任务间隙当中执行 UI<br>更新操作。设想一个常见的场景：如果我们需要渲染一个由十万条数据组成的列表，那么相比一次性渲染全部数据，我们可以将数据分段，使用 setTimeout API<br>去分步处理，构建渲染列表的工作就被分成了不同的子任务在浏览器中执行。在这些子任务间隙，浏览器得以处理 UI 更新。</p>
<p>React 在 JavaScript 执行层面花费的时间较多，这是因为下面一系列复杂过程所造成的：</p>
<blockquote>
<p>Virtual DOM 构建 → 计算 DOM diff → 生成 render patch</p>
</blockquote>
<p>也就是说，在一定程度上：React 著名的调度策略 – stack reconcile 是 React 的性能瓶颈。因为 React stack<br>reconcile 过程会深度优先遍历所有的 Virtual DOM 节点，进行 diff。整棵 Virtual DOM<br>树计算完成之后，将任务出栈释放主线程。因此，浏览器主线程被 React<br>更新状态任务占据的时候，用户与浏览器进行任何交互都不能得到反馈，只有等到任务结束，才能得到浏览器的响应。</p>
<p>我们来看一个典型的场景，来自文章：[React 的新引擎—React<br>Fiber是什么？](<a href="https://link.zhihu.com/?target=http://www.infoq.com/cn/articles/what-">https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/what-</a><br>the-new-engine-of-react)</p>
<p>这个例子会在页面中创建一个输入框、一个按钮、一个 BlockList 组件。BlockList 组件会根据 NUMBER_OF_BLOCK<br>数值渲染出对应数量的数字显示框，数字显示框显示点击按钮的次数。</p>
<p><img src="https://images.gitbook.cn/06d42e30-cd4f-11e9-b3e5-eb0a42842eb1" alt="enter image description
here"></p>
<p>在这个例子中，我们可以设置 NUMBER_OF_BLOCK 的值为 100000，表示渲染 100000 个矩形框。这时候点击按钮，触发<br>setState，页面开始更新。此时点击输入框，输入一些字符串，比如 “hi，react”，可以看到：页面没有任何响应；等待 7s<br>之后，输入框中突然出现了之前输入的 “hireact”。同时，BlockList 组件也更新了。</p>
<p>显而易见，这样的用户体验并不好。</p>
<p>浏览器主线程在这 7s 的 performance 如下图所示：</p>
<p><img src="https://images.gitbook.cn/2dbfb640-cd4f-11e9-a968-ffa0ed414b87" alt="enter image description
here"></p>
<ul>
<li>黄色部分：是 JavaScript 执行时间，也是 React 占用主线程的时间。</li>
<li>紫色部分：是浏览器重新计算 DOM Tree 的时间。</li>
<li>绿色部分：是浏览器绘制页面的时间。</li>
</ul>
<p>这三种任务，总共占用浏览器主线程 7s 的时间，此时间内浏览器无法与用户交互。主要是黄色部分执行时间较长，占用了 6s，即 React<br>较长时间占用主线程，导致主线程无法响应用户输入。这就是一个典型的例子。</p>
<p>React 核心团队很早之前就预知性能风险的存在，并且持续探索可解决的方式。基于浏览器对 requestIdleCallback 和<br>requestAnimationFrame 这两个 API 的支持，React 团队实现新的调度策略 —— Fiber reconcile。</p>
<p>在应用 React Fiber 的场景下，重复刚才的例子，不会再出现页面卡顿，交互自然而顺畅。</p>
<p>浏览器主线程的 performance 如下图所示：</p>
<p><img src="https://images.gitbook.cn/4b852c00-cd4f-11e9-a968-ffa0ed414b87" alt="enter image description
here"></p>
<p>可以看到：在黄色 JavaScript 执行过程中，也就是 React 占用浏览器主线程期间，浏览器也在重新计算 DOM<br>Tree，并且进行重绘。直观来看，黄色和紫色等互相交替，同时页面截图显示，用户输入得以及时响应。简单说，在 React<br>占用浏览器主线程期间，浏览器也在与用户交互。这显然是“更好的性能”表现。</p>
<h3 id="从-Vue-3-0-动静结合的-Dom-diff-谈起"><a href="#从-Vue-3-0-动静结合的-Dom-diff-谈起" class="headerlink" title="从 Vue 3.0 动静结合的 Dom diff 谈起"></a>从 Vue 3.0 动静结合的 Dom diff 谈起</h3><p>Vue3.0 提出的动静结合的 DOM diff 思想，我个人认为是 Vue 近几年在“创新”上的一个很好体现。之所以能够做到动静结合的 DOM<br>diff，或者把这个问题放得更大：之所以能够做到预编译优化，是因为 Vue core 可以静态分析 template，在解析模版时，整个 parse<br>的过程是利用正则表达式顺序解析模板，当解析到开始标签、闭合标签和文本的时候都会分别执行对应的回调函数，来达到构造 AST 树的目的。</p>
<p><img src="https://images.gitbook.cn/945db370-cd4f-11e9-a6b5-097d100ec5bd" alt="enter image description
here"></p>
<p>这个过程换成代码如下：</p>
<p><img src="https://images.gitbook.cn/4f04c060-cd50-11e9-b604-8f8ee8a124cd" alt="enter image description
here"></p>
<p>借助预编译过程，Vue 可以做到的预编译优化就很强大了。比如在预编译时标记出模版中可能变化的组件节点，再次进行渲染前 diff<br>时就可以跳过“永远不会变化的节点”，而只需要对比“可能会变化的动态节点”。这也就是动静结合的 DOM diff 将 diff<br>成本与模版大小正相关优化到与动态节点正相关的理论依据。</p>
<p>类似地，我们也可以标记出来一些“快速通道（fast path）”。比如某个复杂的组件之所以 className<br>发生变化（这个场景很常见，我们根据变量，通过更改 className 来应用不同的样式）。针对这种场景，我们在预编译阶段进行特定的标记，在重新渲染 diff<br>时只需要更新新的 className 即可。</p>
<h4 id="预编译优化的本质是什么？"><a href="#预编译优化的本质是什么？" class="headerlink" title="预编译优化的本质是什么？"></a>预编译优化的本质是什么？</h4><p>我关心的是：React 能否像 Vue 那样进行预编译优化？</p>
<p>Vue 需要做数据双向绑定，需要进行数据拦截或代理，那它就需要在预编译阶段静态分析模版，分析出视图依赖了哪些数据，进行响应式处理。而 React<br>就是局部重新渲染，React 拿到的或者说掌管的，所负责的就是一堆递归 React.createElement 的执行调用，它无法从模版层面进行静态分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">比如这样的 JSX：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;span&gt; This is a test &lt;&#x2F;span&gt;</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">将会被编译为：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    React.createElement(</span><br><span class="line">      &quot;div&quot;, null, </span><br><span class="line">      React.createElement(</span><br><span class="line">        &quot;p&quot;, null, </span><br><span class="line">        React.createElement(</span><br><span class="line">          &quot;span&quot;, null, &quot;This is a test&quot;</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>因此 React JSX 过度的灵活性导致运行时可以用于优化的信息不足。但是，在 React<br>框架之外，我们作为开发者还是可以通过工程化手段达到类似的目的，因为我们能够接触到 JSX 编译成 React.createElement<br>的整个过程。开发者在项目中开发 babel 插件，实现 JSX 编译成 React.createElement，那么优化手段就是是从编写 babel<br>插件开始：</p>
<p>如图：</p>
<p><img src="https://images.gitbook.cn/883ba9c0-cd50-11e9-b604-8f8ee8a124cd" alt="enter image description
here"></p>
<p>那么到底开发者应该怎么做，实现预编译优化呢？</p>
<p>为此我挑出了一些具有代表性的案例，这些案例都是由开发者开发 Babel plugin 实现的 React 预编译手段。</p>
<h5 id="Hoist-constant-elements"><a href="#Hoist-constant-elements" class="headerlink" title="Hoist constant elements"></a><strong>Hoist constant elements</strong></h5><p>将静态不变的节点在预编译阶段就抽象成函数或者静态变量，这个和 Vue<br>框架内所做的一样，不过需要开发者实现，这样一来就不需要在每次重新渲染时生成多余实例，只需要调用 _ref 变量即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const _ref &#x3D; &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&#123;this.props.className&#125;&gt;</span><br><span class="line">        &#123;_ref&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="remove-propTypes-in-runtime"><a href="#remove-propTypes-in-runtime" class="headerlink" title="remove propTypes in runtime"></a><strong>remove propTypes in runtime</strong></h5><p>PropTypes 提供了许多验证工具，用来帮助确定 React 组件中 props 数据的有效性。但是，React v15.5 后就被移除了<br>PropTypes ，因此现在使用 prop-types 库代替。</p>
<p>propTypes 对于业务开发非常有用，帮助我们弥补了 JS 数据类型检查的不足。但是在线上代码中，propTypes 是多余的。</p>
<p>因此在运行时代码删除 propTypes 就变的比较有必要了。</p>
<h5 id="remove-inline-functions-and-varaibles"><a href="#remove-inline-functions-and-varaibles" class="headerlink" title="remove inline functions and varaibles"></a><strong>remove inline functions and varaibles</strong></h5><p>第三个优化场景是这样的：我们知道组件内如果存在函数生成（箭头函数定义，bind<br>使用）或者闭包变量的情况下，组件每一次刷新，都会生成一个新的函数或者闭包变量。我们将这种不必要的函数称为 inline functions。</p>
<p>比如下面这段代码中，transformeData 和 onClick 对应的匿名函数，都会随着组件渲染重新生成一个全新的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export default (&#123; data, sortComparator, filterPredicate, history &#125;) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const transformedData &#x3D; data</span><br><span class="line">    .filter(filterPredicate)</span><br><span class="line">    .sort(sortComparator)</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button </span><br><span class="line">        className&#x3D;&quot;back-btn&quot; </span><br><span class="line">        onClick&#x3D;&#123;() &#x3D;&gt; history.pop()&#125; </span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">      &lt;ul className&#x3D;&quot;data-list&quot;&gt;</span><br><span class="line">        &#123;transformedData.map((&#123; id, value &#125;) &#x3D;&gt; (</span><br><span class="line">          &lt;Item value&#x3D;&#123;value&#125;&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;&#x2F;ul&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反复生成这些 inline functions 或者数据，这对于 React 运行时性能或多或少会有一点影响，也带来了 GC 压力。</p>
<p>我们在工程中，可以通过插件对 inline functions 或者变量进行内存持久化处理。最终经过预编译优化后的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> let _anonymousFnComponent</span><br><span class="line"></span><br><span class="line">export default (&#123; data, sortComparator, filterPredicate, history &#125;) &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">  const transformedData &#x3D; React.useMemo(</span><br><span class="line">    () &#x3D;&gt;</span><br><span class="line">    data.filter(filterPredicate).sort(sortComparator),</span><br><span class="line">    [data, data.filter, filterPredicate, sortComparator]</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return React.createElement(_anonymousFnComponent &#x3D; _anonymousFnComponent || (() &#x3D;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    const _onClick2 &#x3D; React.useCallback(</span><br><span class="line">      () &#x3D;&gt; history.pop(), </span><br><span class="line">      [history, history.pop]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button className&#x3D;&quot;back-btn&quot; onClick&#x3D;&#123;_onClick2&#125; &#x2F;&gt;</span><br><span class="line">        &lt;ul className&#x3D;&quot;data-list&quot;&gt;</span><br><span class="line">          &#123;transformedData.map((&#123; id, value &#125;) &#x3D;&gt;</span><br><span class="line">            React.createElement(</span><br><span class="line">              &#x2F;&#x2F;...</span><br><span class="line">            )</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;), null)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们使用了 React 新特性 useMemo 和 useCallback 将这些变量包裹。 useMemo 和 useCallback<br>都会在组件第一次渲染的时候执行，之后会在其依赖的变量，也就是 useMemo 和 useCallback<br>的第二个参数数组，数组内的数值发生改变时再次执行；这两个 hooks 都返回缓存的值，useMemo 返回缓存的变量，useCallback<br>返回缓存的函数。</p>
<p>我们看代码，transformeData 在其数据源：data,data.filter,filterPredicate,sortComparator<br>发生变化时才会更新，才会重新生成一份<br>transformeData，函数渲染时只要依赖的data,data.filter,filterPredicate,sortComparator<br>不变，不会重新生成 transformeData，而是使用缓存的值。onClick 也使用了 useCallback 将函数引用持久化保存，道理一样。</p>
<p>这样一来就避免了在组件重新渲染时，总是生成不必要的 inline functions 和闭包变量的困扰。</p>
<h5 id="transform-to-stateless-function-component"><a href="#transform-to-stateless-function-component" class="headerlink" title="transform to stateless function component"></a><strong>transform to stateless function component</strong></h5><p>我们知道函数式组件虽然未来会比 class 声明的组件性能更好，并且函数不管是从性能上、可组合性上还是 TS 契合度上，都要要优于 class 使用。</p>
<p>这个例子，我们将符合条件的 class 声明组件自动在预编译阶段转化为函数式组件。</p>
<p>我们的目标是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  static propTypes &#x3D; &#123;</span><br><span class="line">    className: React.PropTypes.string.isRequired</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&#123;this.props.className&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在预编译阶段优化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    const MyComponent &#x3D; props &#x3D;&gt; </span><br><span class="line">      &lt;div className&#x3D;&#123;props.className&#125;&gt;</span><br><span class="line">        &lt;span&gt;Hello World&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">    MyComponent.propTypes &#x3D; &#123;</span><br><span class="line">      className: React.PropTypes.string.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">在这里我们展开实现一下 Babel plugin 的编写，其中会涉及到一些 AST 的内容，读者只需明白思想方向即可。</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#96;&#96;&#96; tsx     </span><br><span class="line">    module.exports &#x3D; function(&#123; types: t &#125;) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        visitor: &#123;</span><br><span class="line">          Class(path) &#123;</span><br><span class="line">            const state &#x3D; &#123;</span><br><span class="line">              renderMethod: null,</span><br><span class="line">              properties: [],</span><br><span class="line">              thisProps: [],</span><br><span class="line">              isPure: true</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            path.traverse(bodyVisitor, state)</span><br><span class="line">    </span><br><span class="line">            let replacement &#x3D; []</span><br><span class="line">    </span><br><span class="line">            state.thisProps.forEach(function(thisProp) &#123;</span><br><span class="line">              thisProp.replaceWith(t.identifier(&#39;props&#39;))</span><br><span class="line">              thisProp.replaceWith(t.identifier(&#39;props&#39;))</span><br><span class="line">            &#125;)</span><br><span class="line">    </span><br><span class="line">            replacement.push(</span><br><span class="line">              t.functionDeclaration(</span><br><span class="line">                id,</span><br><span class="line">                [t.identifier(&#39;props&#39;)],</span><br><span class="line">                state.renderMethod.node.body</span><br><span class="line">              )</span><br><span class="line">            )</span><br><span class="line">    </span><br><span class="line">            state.properties.forEach(prop &#x3D;&gt; &#123;</span><br><span class="line">              replacement.push(t.expressionStatement(</span><br><span class="line">                t.assignmentExpression(&#39;&#x3D;&#39;,</span><br><span class="line">                  t.MemberExpression(id, prop.node.key),</span><br><span class="line">                  prop.node.value</span><br><span class="line">                )</span><br><span class="line">              ))</span><br><span class="line">            &#125;)</span><br><span class="line">    </span><br><span class="line">            if (t.isExpression(path.node)) &#123;</span><br><span class="line">              replacement.push(t.returnStatement(id))</span><br><span class="line">    </span><br><span class="line">              replacement &#x3D; t.callExpression(</span><br><span class="line">                t.functionExpression(null, [],</span><br><span class="line">                  t.blockStatement(replacement)</span><br><span class="line">                ),</span><br><span class="line">                []</span><br><span class="line">              )</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">            path.replaceWithMultiple(</span><br><span class="line">              replacement</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      const bodyVisitor &#x3D; &#123;</span><br><span class="line">        ClassMethod(path) &#123;</span><br><span class="line">          if (path.node.key.name &#x3D;&#x3D;&#x3D; &#39;render&#39;) &#123;</span><br><span class="line">            this.renderMethod &#x3D; path</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.isPure &#x3D; false</span><br><span class="line">            path.stop()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    </span><br><span class="line">        ClassProperty(path) &#123;</span><br><span class="line">          const name &#x3D; path.node.key.name</span><br><span class="line">    </span><br><span class="line">          if (path.node.static &amp;&amp; (</span><br><span class="line">            name &#x3D;&#x3D;&#x3D; &#39;propTypes&#39; ||</span><br><span class="line">            name &#x3D;&#x3D;&#x3D; &#39;defaultProps&#39;</span><br><span class="line">          )) &#123;</span><br><span class="line">            this.properties.push(path)</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.isPure &#x3D; false</span><br><span class="line">            this.isPure &#x3D; false</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    </span><br><span class="line">        MemberExpression(path) &#123;</span><br><span class="line">          this.thisProps.push(path)</span><br><span class="line">        &#125;,</span><br><span class="line">    </span><br><span class="line">        JSXIdentifier(path) &#123;</span><br><span class="line">          if (path.node.name &#x3D;&#x3D;&#x3D; &#39;ref&#39;) &#123;</span><br><span class="line">            this.isPure &#x3D; false</span><br><span class="line">            path.stop()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>代码分析：我们先明确，什么样的 class 组件，具备转换成函数式组件的条件？</p>
<p>首先，class 组件不能具有 this.state 的引用，组件不能出现任何生命周期方法，也不能出现<br>createRef，因为这些特性在函数式组件中并不存在。</p>
<p>满足这样的条件时，我们在进行 JSX 转换过程进行组件替换：通过 AST 进行遍历， 首先在遍历过程中找到符合条件的 class 组件，是否符合条件我们用<br>isPure 来进行标记， 同时在遍历时，对每一个符合条件的 class 组件，储存 render 方法，作为转换函数式组件的返回值；储存<br>propTypes 和 defaultProps 静态属性，之后会挂载在函数组件函数属性上；同时对 this.props 的用法转为 props,<br>props 作为函数式组件的参数出现 最后在按照上述规则，修改 AST 树，新的 AST 树相关组件节点会生成函数式组件。</p>
<h4 id="Prepack-对于框架的影响"><a href="#Prepack-对于框架的影响" class="headerlink" title="Prepack 对于框架的影响"></a>Prepack 对于框架的影响</h4><p>Prepack 同样是 FaceBook 团队的作品。它让你编写普通的 JavaScript<br>代码，它在构建阶段就试图了解代码将做什么，然后生成等价的代码，减少了运行时的计算量。</p>
<p>我们看一个 fibonacci 数列求和的例子，再经过 prepack 处理之后，直接输出结果，运行时就是一个 610 这么一个结果。这么看 prepack<br>是一个 JavaScript 的部分求值器（Partial Evaluator），可在编译时执行原本在运行时的计算过程，并通过重写 JavaScript<br>代码来提高其执行效率。</p>
<p>我就用 Prepack 结合 React 尝了个鲜：</p>
<p><img src="https://images.gitbook.cn/a720c050-cd50-11e9-a6b5-097d100ec5bd" alt="enter image description
here"></p>
<p><img src="https://images.gitbook.cn/b89d11d0-cd50-11e9-a968-ffa0ed414b87" alt="enter image description
here"></p>
<p>上图左边部分是我编写的代码，在不使用 prepack 情况下，运行时代码如右边所示：经过编译之后右边的代码仍然是对数组 list 进行<br>map，逐条渲染出数组内容。</p>
<p>经过 preack 优化后，运行时代码已经非常轻量了。运行时就减少 map 的计算等，直接用生成的组件内容作为运行时结果。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>框架的性能实际上要分两方面来学习：一方面是使用层面，我们需要了解框架，进而保证达到性能优化；另一方面需要了解框架实现，思考作者在框架编译时和运行时两个重要环节是如何进行处理，持续进行优化的。</p>
<p>总而言之，框架的性能优化仍然属于语言范畴和浏览器范畴的优化，一些思想具有共通性，希望大家一起积累思考。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/037--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/">https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/037--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8B%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/2020/12/22/advanced/036--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶36 | 以 React 为例，说说框架和性能（上）</div></div></a></div><div class="next-post pull-right"><a href="/matrix/2020/12/22/advanced/041--%E5%8F%A4%E8%80%81%E5%8F%88%E6%96%B0%E6%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶41 | 古老又新潮的函数式</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/matrix/null" onerror="this.onerror=null;this.src='/matrix/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">React 性能设计亮点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B9%8B%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">React 性能设计亮点之事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B9%8B-setState"><span class="toc-number">1.2.</span> <span class="toc-text">React 性能设计亮点之 setState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#React-%E6%80%A7%E8%83%BD%E8%AE%BE%E8%AE%A1%E4%BA%AE%E7%82%B9%E4%B9%8B-React-fiber"><span class="toc-number">1.3.</span> <span class="toc-text">React 性能设计亮点之 React fiber</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-Vue-3-0-%E5%8A%A8%E9%9D%99%E7%BB%93%E5%90%88%E7%9A%84-Dom-diff-%E8%B0%88%E8%B5%B7"><span class="toc-number">2.</span> <span class="toc-text">从 Vue 3.0 动静结合的 Dom diff 谈起</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">预编译优化的本质是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Hoist-constant-elements"><span class="toc-number">2.1.1.</span> <span class="toc-text">Hoist constant elements</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-propTypes-in-runtime"><span class="toc-number">2.1.2.</span> <span class="toc-text">remove propTypes in runtime</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#remove-inline-functions-and-varaibles"><span class="toc-number">2.1.3.</span> <span class="toc-text">remove inline functions and varaibles</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#transform-to-stateless-function-component"><span class="toc-number">2.1.4.</span> <span class="toc-text">transform to stateless function component</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prepack-%E5%AF%B9%E4%BA%8E%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">2.2.</span> <span class="toc-text">Prepack 对于框架的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="01 | 项目基石：前端脚手架工具探秘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘">01 | 项目基石：前端脚手架工具探秘</a><time datetime="2020-12-22T12:51:17.448Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）">核心进阶25 | 深入浅出模块化（含 tree shaking）（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶29 | 前端工程化背后的项目组织设计（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）">核心进阶29 | 前端工程化背后的项目组织设计（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶30 | 代码规范工具及背后技术设计（上）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）">核心进阶30 | 代码规范工具及背后技术设计（上）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>