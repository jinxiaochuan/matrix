<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶17 | 触类旁通多种框架 | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？ 我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。 相关知识点如下：  我把现代框架的">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶17 | 触类旁通多种框架">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/advanced/017--%E8%A7%A6%E7%B1%BB%E6%97%81%E9%80%9A%E5%A4%9A%E7%A7%8D%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？ 我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。 相关知识点如下：  我把现代框架的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360">
<meta property="article:published_time" content="2020-12-23T03:47:50.492Z">
<meta property="article:modified_time" content="2020-12-23T03:47:50.492Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/advanced/017--%E8%A7%A6%E7%B1%BB%E6%97%81%E9%80%9A%E5%A4%9A%E7%A7%8D%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-23 11:47:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="onerror=null;src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶17 | 触类旁通多种框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-23T03:47:50.492Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-23T03:47:50.492Z" title="更新于 2020-12-23 11:47:50">2020-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>框架在任何一种语言编程范畴中都扮演了举足轻重的地位，前端尤是如此。目前流行的前端框架三驾马车：Angular、React 和<br>Vue，它们各有特点和受众，都值得开发者认真思考和学习。那么我们在精力有限的情况下，如何做到“触类旁通”、如何提取框架共性、提高学习和应用效率呢？</p>
<p>我们这一讲就来剖析这些框架的特点和本质，介绍如何学习并使用这些框架，进而了解前端框架的真谛。</p>
<p>相关知识点如下：</p>
<p><img src="https://images.gitbook.cn/ff71bef0-9234-11e9-b195-bf69c03485a0"></p>
<p>我把现代框架的关键词进行提炼，掌握这些关键词，是我们学习的重要环节。这些关键词有：双向绑定、依赖收集、发布订阅模式、MVVM / MVC、虚拟 DOM、虚拟<br>DOM diff、模版编译等。</p>
<h3 id="响应式框架基本原理"><a href="#响应式框架基本原理" class="headerlink" title="响应式框架基本原理"></a>响应式框架基本原理</h3><p>我们不再赘述响应式或数据双向绑定的基本概念，这里直接思考其行为：直观上，数据在变化时，不再需要开发者去手动更新视图，而视图会根据变化的数据“自动”进行更新。想完成这个过程，我们需要：</p>
<ul>
<li>收集视图依赖了哪些数据</li>
<li>感知被依赖数据的变化</li>
<li>数据变化时，自动“通知”需要更新的视图部分，并进行更新</li>
</ul>
<p>道理很简单，这个思考过程换成对应的技术概念就是：</p>
<ul>
<li>依赖收集</li>
<li>数据劫持 / 数据代理</li>
<li>发布订阅模式</li>
</ul>
<p>接下来，我们一步步拆解。</p>
<h4 id="数据劫持与代理"><a href="#数据劫持与代理" class="headerlink" title="数据劫持与代理"></a>数据劫持与代理</h4><p>感知数据变化的方法很直接，就是进行数据劫持或数据代理。我们往往通过 Object.defineProperty 实现。这个方法可以定义数据的 getter<br>和 setter，具体用法不再赘述。下面来看一个场景：</p>
<pre><code>let data = &#123;
  stage: &#39;GitChat&#39;,
  course: &#123;
    title: &#39;前端开发进阶&#39;,
    author: &#39;Lucas&#39;,
    publishTime: &#39;2018 年 5 月&#39;
  &#125;
&#125;

Object.keys(data).forEach(key =&gt; &#123;
  let currentValue = data[key]

  Object.defineProperty(data, key, &#123;
    enumerable: true,
    configurable: false,
    get() &#123;
      console.log(`getting $&#123;key&#125; value now, getting value is:`, currentValue)
      return currentValue
    &#125;,
    set(newValue) &#123;
      currentValue = newValue
      console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
    &#125;
  &#125;)
&#125;) </code></pre>
<p>这段代码对 data 数据的 getter 和 setter 进行定义拦截，当我们读取或者改变 data 的值时：</p>
<pre><code>data.course

// getting course value now, getting value is: &#123;title: &quot;前端开发进阶&quot;, author: &quot;Lucas&quot;, publishTime: &quot;2018 年 5 月&quot;&#125;



data.course = &#39;前端开发进阶2&#39;
// setting course value now, setting value is 前端开发进阶2</code></pre>
<p>但是这种实现有一个问题，例如：</p>
<pre><code>data.course.title = &#39;前端开发进阶2&#39;

// getting course value now, getting value is: &#123;title: &quot;前端开发进阶&quot;, author: &quot;Lucas&quot;, publishTime: &quot;2018 年 5 月&quot;&#125;</code></pre>
<p>只会有 getting course value now, getting value is: {title: “前端开发进阶”, author:<br>“Lucas”, publishTime: “2018 年 5 月”} 的输出，这是因为我们尝试读取了 data.course 信息。但是修改<br>data.course.title 的信息并没有打印出来。</p>
<p>出现这个问题的原因是因为我们的实现代码只进行了一层 Object.defineProperty，或者说只对 data 的第一层属性进行了<br>Object.defineProperty，对于嵌套的引用类型数据结构：data.course，我们同样应该进行拦截。</p>
<p>为了达到深层拦截的目的，将 Object.defineProperty 的逻辑抽象为 observe 函数，并改用递归实现：</p>
<pre><code>let data = &#123;
  stage: &#39;GitChat&#39;,
  course: &#123;
    title: &#39;前端开发进阶&#39;,
    author: &#39;Lucas&#39;,
    publishTime: &#39;2018 年 5 月&#39;
  &#125;
&#125;

const observe = data =&gt; &#123;
  if (!data || typeof data !== &#39;object&#39;) &#123;
      return
  &#125;
  Object.keys(data).forEach(key =&gt; &#123;
    let currentValue = data[key]

    observe(currentValue)

    Object.defineProperty(data, key, &#123;
      enumerable: true,
      configurable: false,
      get() &#123;
        console.log(`getting $&#123;key&#125; value now, getting value is:`, currentValue)
        return currentValue
      &#125;,
      set(newValue) &#123;
        currentValue = newValue
        console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
      &#125;
    &#125;)
  &#125;) 
&#125;

observe(data)</code></pre>
<p>这样一来，就实现了深层数据拦截：</p>
<pre><code>data.course.title = &#39;前端开发进阶2&#39;

// getting course value now, getting value is: &#123;// ...&#125;
// setting title value now, setting value is 前端开发进阶2</code></pre>
<p>请注意，我们在 set 代理中，并没有对 newValue 再次递归进行 observe(newValue)。也就是说，如果赋值是一个引用类型：</p>
<pre><code>data.course.title = &#123;
    title: &#39;前端开发进阶2&#39;
&#125;</code></pre>
<p>无法实现对 data.course.title 数据的观察。这里为了简化学习成本，默认修改的数值符合语义，都是基本类型。</p>
<p>在尝试对 data.course.title 赋值时，首先会读取 data.course，因此输出：getting course value now,<br>getting value is: {// …}，赋值后，触发 data.course.title 的 setter，输出：setting title<br>value now, setting value is 前端开发进阶2。</p>
<p>因此我们总结出：对数据进行拦截并不复杂，这也是很多框架实现的第一步。</p>
<h4 id="监听数组变化"><a href="#监听数组变化" class="headerlink" title="监听数组变化"></a>监听数组变化</h4><p>如果上述数据中某一项变为数组：</p>
<pre><code>let data = &#123;
  stage: &#39;GitChat&#39;,
  course: &#123;
    title: &#39;前端开发进阶&#39;,
    author: [&#39;Lucas&#39;, &#39;Ronaldo&#39;],
    publishTime: &#39;2018 年 5 月&#39;
  &#125;
&#125;

const observe = data =&gt; &#123;
  if (!data || typeof data !== &#39;object&#39;) &#123;
      return
  &#125;
  Object.keys(data).forEach(key =&gt; &#123;
    let currentValue = data[key]

    observe(currentValue)

    Object.defineProperty(data, key, &#123;
      enumerable: true,
      configurable: false,
      get() &#123;
        console.log(`getting $&#123;key&#125; value now, getting value is:`, currentValue)
        return currentValue
      &#125;,
      set(newValue) &#123;
        currentValue = newValue
        console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
      &#125;
    &#125;)
  &#125;) 
&#125;

observe(data)


data.course.author.push(&#39;Messi&#39;)
// getting course value now, getting value is: &#123;//...&#125;
// getting author value now, getting value is: (2)&amp;nbsp;[(...), (...)]</code></pre>
<p>我们只监听到了 data.course 以及 data.course.author 的读取，而数组 push 行为并没有被拦截。这是因为<br>Array.prototype 上挂载的方法并不能触发 data.course.author 属性值的 setter，由于这并不属于做赋值操作，而是<br>push API 调用操作。然而对于框架实现来说，这显然是不满足要求的，当数组变化时我们应该也有所感知。</p>
<p>Vue 同样存在这样的问题，它的解决方法是：将数组的常用方法进行重写，进而覆盖掉原生的数组方法，重写之后的数组方法需要能够被拦截。</p>
<p>实现逻辑如下：</p>
<pre><code>const arrExtend = Object.create(Array.prototype)
const arrMethods = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]

arrMethods.forEach(method =&gt; &#123;
  const oldMethod = Array.prototype[method]
  const newMethod = function(...args) &#123;
    oldMethod.apply(this, args)
    console.log(`$&#123;method&#125; 方法被执行了`)
  &#125;
  arrExtend[method] = newMethod
&#125;)</code></pre>
<p>对于数组原生的 7 个方法：</p>
<ul>
<li>push</li>
<li>pop</li>
<li>shift</li>
<li>unshift</li>
<li>splice</li>
<li>sort</li>
<li>reverse</li>
</ul>
<p>进行重写，核心操作还是调用原生方法：oldMethod.apply(this, args)，除此之外可以在调用 oldMethod.apply(this,<br>args) 前后加入我们需要的任何逻辑。示例代码中加入了一行 console.log。使用时：</p>
<pre><code>Array.prototype = Object.assign(Array.prototype, arrExtend)

let array = [1, 2, 3]
array.push(4)
// push 方法被执行了</code></pre>
<p>对应我们的代码：</p>
<pre><code>const arrExtend = Object.create(Array.prototype)
const arrMethods = [
  &#39;push&#39;,
  &#39;pop&#39;,
  &#39;shift&#39;,
  &#39;unshift&#39;,
  &#39;splice&#39;,
  &#39;sort&#39;,
  &#39;reverse&#39;
]

arrMethods.forEach(method =&gt; &#123;
  const oldMethod = Array.prototype[method]
  const newMethod = function(...args) &#123;
    oldMethod.apply(this, args)
    console.log(`$&#123;method&#125; 方法被执行了`)
  &#125;
  arrExtend[method] = newMethod
&#125;)

Array.prototype = Object.assign(Array.prototype, arrExtend)


let data = &#123;
  stage: &#39;GitChat&#39;,
  course: &#123;
    title: &#39;前端开发进阶&#39;,
    author: [&#39;Lucas&#39;, &#39;Ronaldo&#39;],
    publishTime: &#39;2018 年 5 月&#39;
  &#125;
&#125;

const observe = data =&gt; &#123;
  if (!data || typeof data !== &#39;object&#39;) &#123;
      return
  &#125;
  Object.keys(data).forEach(key =&gt; &#123;
    let currentValue = data[key]

    observe(currentValue)

    Object.defineProperty(data, key, &#123;
      enumerable: true,
      configurable: false,
      get() &#123;
        console.log(`getting $&#123;key&#125; value now, getting value is:`, currentValue)
        return currentValue
      &#125;,
      set(newValue) &#123;
        currentValue = newValue
        console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
      &#125;
    &#125;)
  &#125;) 
&#125;

observe(data)

data.course.author.push(&#39;Messi&#39;)</code></pre>
<p>将会输出：</p>
<pre><code>getting course value now, getting value is: &#123;//...&#125;
getting author value now, getting value is: (2)&amp;nbsp;[(...), (...)]
// push 方法被执行了</code></pre>
<p>这种 monkey patch 本质是重写原生方法，这天生不是很安全，也很不优雅，能有更好的实现吗？</p>
<p>答案是有的，使用 ES Next 的新特性——Proxy，之前也介绍过，它可以完成对数据的代理。</p>
<p>那么这两种方式有何区别呢？请继续阅读。</p>
<h4 id="Object-defineProperty-VS-Proxy"><a href="#Object-defineProperty-VS-Proxy" class="headerlink" title="Object.defineProperty VS Proxy"></a>Object.defineProperty VS Proxy</h4><p>我们首先尝试使用 Proxy 来完成代码重构：</p>
<pre><code>let data = &#123;
  stage: &#39;GitChat&#39;,
  course: &#123;
    title: &#39;前端开发进阶&#39;,
    author: [&#39;Lucas&#39;],
    publishTime: &#39;2018 年 5 月&#39;
  &#125;
&#125;

const observe = data =&gt; &#123;
  if (!data || Object.prototype.toString.call(data) !== &#39;[object Object]&#39;) &#123;
      return
  &#125;

  Object.keys(data).forEach(key =&gt; &#123;
    let currentValue = data[key]
    // 事实上 proxy 也可以对函数类型进行代理。这里只对承载数据类型的 object 进行处理，读者了解即可。
    if (typeof currentValue === &#39;object&#39;) &#123;
      observe(currentValue)
      data[key] = new Proxy(currentValue, &#123;
        set(target, property, value, receiver) &#123;
          // 因为数组的 push 会引起 length 属性的变化，所以 push 之后会触发两次 set 操作，我们只需要保留一次即可，property 为 length 时，忽略
          if (property !== &#39;length&#39;) &#123;
            console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
          &#125;
          return Reflect.set(target, property, value, receiver)
        &#125;
      &#125;)
    &#125;
    else &#123;
      Object.defineProperty(data, key, &#123;
        enumerable: true,
        configurable: false,
        get() &#123;
          console.log(`getting $&#123;key&#125; value now, getting value is:`, currentValue)
          return currentValue
        &#125;,
        set(newValue) &#123;
          currentValue = newValue
          console.log(`setting $&#123;key&#125; value now, setting value is`, currentValue)
        &#125;
      &#125;)
    &#125;
  &#125;) 
&#125;

observe(data)</code></pre>
<p>此时对数组进行操作：</p>
<pre><code>data.course.author.push(&#39;messi&#39;)
// setting author value now, setting value is [&quot;Lucas&quot;]</code></pre>
<p>已经符合我们的需求了。注意这里在使用 Proxy 进行代理时，并没有对 getter 进行代理，因此上述代码的输出结果并不像之前使用<br>Object.defineProperty 那样也会有 getting value 输出。</p>
<p>整体实现并不难理解，需要读者了解最基本的 Proxy 知识。简单总结一下，对于数据键值为基本类型的情况，我们使用<br>Object.defineProperty；对于键值为对象类型的情况，继续递归调用 observe 方法，并通过 Proxy 返回的新对象对<br>data[key] 重新赋值，这个新值的 getter 和 setter 已经被添加了代理。</p>
<p>了解了 Proxy 实现之后，我们对 Proxy 实现数据代理和 Object.defineProperty 实现数据拦截进行对比，会发现：</p>
<ul>
<li>Object.defineProperty 不能监听数组的变化，需要进行数组方法的重写</li>
<li>Object.defineProperty 必须遍历对象的每个属性，且对于嵌套结构需要深层遍历</li>
<li>Proxy 的代理是针对整个对象的，而不是对象的某个属性，因此不同于 Object.defineProperty 的必须遍历对象每个属性，Proxy 只需要做一层代理就可以监听同级结构下的所有属性变化，当然对于深层结构，递归还是需要进行的</li>
<li>Proxy 支持代理数组的变化</li>
<li>Proxy 的第二个参数除了 set 和 get 以外，可以有 13 种拦截方法，比起 Object.defineProperty() 更加强大，这里不再一一列举</li>
<li>Proxy 性能将会被底层持续优化，而 Object.defineProperty 已经不再是优化重点</li>
</ul>
<h3 id="模版编译原理介绍"><a href="#模版编译原理介绍" class="headerlink" title="模版编译原理介绍"></a>模版编译原理介绍</h3><p>到此，我们了解了如何监听数据的变化，那么下一步呢？以类 Vue 框架为例，我们看看一个典型的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    &lt;body&gt;</span><br><span class="line">      &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;stage&#125;&#125; 平台课程：&#123;&#123;course.title&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;course.title&#125;&#125; 是 &#123;&#123;course.author&#125;&#125; 发布的课程&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;发布时间为 &#123;&#123;course.publishTime&#125;&#125; &lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line">      &lt;script&gt;</span><br><span class="line">        let vue &#x3D; new Vue(&#123; </span><br><span class="line">          ele: &#39;#app&#39;, </span><br><span class="line">          data: &#123;</span><br><span class="line">            stage: &#39;GitChat&#39;,</span><br><span class="line">            course: &#123;</span><br><span class="line">              title: &#39;前端开发进阶&#39;,</span><br><span class="line">              author: &#39;Lucas&#39;,</span><br><span class="line">              publishTime: &#39;2018 年 5 月&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">其中模版变量使用了 &#123;&#123;&#125;&#125; 的表达方式输出模版变量。最终输出的 HTML</span><br><span class="line">内容应该被合适的数据进行填充替换，因此还需要一步编译过程，该过程任何框架或类库中都是相通的，比如 React 中的 JSX，也是编译为</span><br><span class="line">React.createElement，并在生成虚拟 DOM 时进行数据填充。</span><br><span class="line"></span><br><span class="line">我们这里简化过程，将模版内容：</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">        &lt;h1&gt;&#123;&#123;stage&#125;&#125; 平台课程：&#123;&#123;course.title&#125;&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123;course.title&#125;&#125; 是 &#123;&#123;course.author&#125;&#125; 发布的课程&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;发布时间为 &#123;&#123;course.publishTime&#125;&#125; &lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">输出为真实 HTML 即可。</span><br></pre></td></tr></table></figure>
<h4 id="模版编译实现"><a href="#模版编译实现" class="headerlink" title="模版编译实现"></a>模版编译实现</h4><p>一提到这样的“模版编译”过程，很多开发者都会想到词法分析，也许都会感到头大。其实原理很简单，就是使用正则 +<br>遍历，有时也需要一些算法知识，我们来看现在的场景，只需要对 #app 节点下内容进行替换，通过正则识别出模版变量，获取对应的数据即可：</p>
<pre><code>compile(document.querySelector(&#39;#app&#39;), data)

function compile(el, data) &#123;
  let fragment = document.createDocumentFragment()

  while (child = el.firstChild) &#123;
    fragment.appendChild(child)
  &#125;

  // 对 el 里面的内容进行替换
  function replace(fragment) &#123;
    Array.from(fragment.childNodes).forEach(node =&gt; &#123;
      let textContent = node.textContent
      let reg = /\&#123;\&#123;(.*?)\&#125;\&#125;/g

      if (node.nodeType === 3 &amp;&amp; reg.test(textContent)) &#123;
         const nodeTextContent = node.textContent
        const replaceText = () =&gt; &#123;
            node.textContent = nodeTextContent.replace(reg, (matched, placeholder) =&gt; &#123;
                return placeholder.split(&#39;.&#39;).reduce((prev, key) =&gt; &#123;
                    return prev[key]
                &#125;, data)

            &#125;)
        &#125;

        replaceText()
      &#125;

      // 如果还有子节点，继续递归 replace
      if (node.childNodes &amp;&amp; node.childNodes.length) &#123;
        replace(node)
      &#125;
    &#125;)
  &#125;

  replace(fragment)

  el.appendChild(fragment)
  return el
&#125;</code></pre>
<p>代码分析：我们使用 fragment 变量储存生成的真实 HTML 节点内容。通过 replace 方法对  进行数据替换，同时 <br>的表达只会出现在 nodeType === 3 的文本类型节点中，因此对于符合 <code>node.nodeType === 3 &amp;&amp; reg.test(textContent)</code> 条件的情况，进行数据获取和填充。我们借助字符串 replace 方法第二个参数进行一次性替换，此时对于形如</p>
 的深层数据，通过 reduce 方法，获得正确的值。

<p>因为 DOM 结构可能是多层的，所以对存在子节点的节点，依然使用递归进行 replace 替换。</p>
<p>这个编译过程比较简单，没有考虑到边界情况，只是单纯完成模版变量到真实 DOM 的转换，读者只需体会简单道理即可。</p>
<h4 id="双向绑定实现"><a href="#双向绑定实现" class="headerlink" title="双向绑定实现"></a>双向绑定实现</h4><p>上述实现是单向的，数据变化引起了视图变化，那么如果页面中存在一个输入框，如何触发数据变化呢？比如：</p>
<pre><code>&lt;input v-model=&quot;inputData&quot; type = &quot;text&quot; &gt;</code></pre>
<p>我们需要在模版编译中，对于存在 v-model 属性的 node 进行事件监听，在输入框输入时，改变 v-model 属性值对应的数据即可（这里为<br>inputData），增加 compile 中的 replace 方法逻辑，对于 node.nodeType === 1 的 DOM 类型，伪代码如下：</p>
<pre><code>function replace(el, data) &#123;
  // 省略...
  if (node.nodeType === 1) &#123;

    let attributesArray = node.attributes

    Array.from(attributesArray).forEach(attr =&gt; &#123;
      let attributeName = attr.name
      let attributeValue = attr.value

      if (name.includes(&#39;v-&#39;)) &#123;
        node.value = data[attributeValue]
      &#125;

      node.addEventListener(&#39;input&#39;, e =&gt; &#123;
        let newVal = e.target.value
        data[attributeValue] = newVal
        // ...
        // 更改数据源，触发 setter
        // ...
      &#125;)
    &#125;)

  &#125;

  if (node.childNodes &amp;&amp; node.childNodes.length) &#123;
    replace(node)
  &#125;
&#125;</code></pre>
<h3 id="发布订阅模式简单应用"><a href="#发布订阅模式简单应用" class="headerlink" title="发布订阅模式简单应用"></a>发布订阅模式简单应用</h3><p>作为前端开发人员，我们对于所谓的“事件驱动”理念——即“事件发布订阅模式（Pub/Sub 模式）”一定再熟悉不过了。这种模式在 JavaScript<br>里面有与生俱来的基因：我们可以认为 JavaScript 本身就是事件驱动型语言，比如，应用中对一个 button<br>进行了事件绑定，用户点击之后就会触发按钮上面的 click 事件。这是因为此时有特定程序正在监听这个事件，随之触发了相关的处理程序。</p>
<p>这个模式的一个好处之一在于能够解耦，实现“高内聚、低耦合”的理念。这种模式对于我们框架的设计同样也不可或缺。请思考：通过前面内容的学习，我们了解了如何监听数据的变化。如果最终想实现响应式<br>MVVM，或所谓的双向绑定，那么还需要根据这个数据变化作出相应的视图更新。这个逻辑和我们在页面中对 button 绑定事件处理函数是多么相近。</p>
<p>那么这样一个“熟悉的”模式应该怎么实现呢，又该如何在框架中具体应用呢？看代码：</p>
<pre><code>class Notify &#123;
  constructor() &#123;
    this.subscribers = []
  &#125;
  add(handler) &#123;
    this.subscribers.push(handler)
  &#125;
  emit() &#123;
    this.subscribers.forEach(subscriber =&gt; subscriber())
  &#125;
&#125;</code></pre>
<p>使用：</p>
<pre><code>let notify = new Notify()

notify.add(() =&gt; &#123;
    console.log(&#39;emit here&#39;)
&#125;)

notify.emit()
// emit here</code></pre>
<p>这就是一个简单实现的“事件发布订阅模式”，当然代码只是启发思路，真实应用还比较“粗糙”，没有进行事件名设置，APIs<br>也并不丰富，但完全能够说明问题了。其实读者翻看 Vue 源码，也能了解 Vue 中的发布订阅模式很简单。</p>
<h3 id="MVVM-融会贯通"><a href="#MVVM-融会贯通" class="headerlink" title="MVVM 融会贯通"></a>MVVM 融会贯通</h3><p>回顾一下前面的基本内容：数据拦截和代理、发布订阅模式、模版编译，那么如何根据这些概念实现一个 MVVM 框架呢？其实不管是 Vue<br>还是其他类库或框架，其解决思想都是建立在前文所述概念之上的。</p>
<p>我们来进行串联，整个过程是：首先对数据进行深度拦截或代理，对每一个属性的 getter 和 setter<br>进行“加工”，该“加工”具体做些什么后面马上会有说明。在模版初次编译时，解析指令（如 v-model），并进行依赖收集（），订阅数据的变化。</p>
<p>这里的依赖收集过程具体指：当调用 compiler 中的 replace<br>方法时，我们会读取数据进行模版变量的替换，这时候“读取数据时”需要做一个标记，用来表示“我依赖这一项数据”，因此我要订阅这个属性值的变化。Vue 中定义一个<br>Watcher 类来表示观察订阅依赖。这就实现了整套流程，换个思路再复述一遍：我们知道模版编译过程中会读取数据，进而触发数据源属性值的<br>getter，因此上面所说的数据代理的“加工”就是在数据监听的 getter 中记录这个依赖，同时在 setter<br>触发数据变化时，执行依赖对应的相关操作，最终触发模版中数据的变化。</p>
<p>我们抽象成流程图来理解：</p>
<p><img src="https://images.gitbook.cn/02926aa0-925b-11e9-a0f8-2d0a45937cae" alt="enter image description
here"></p>
<p>这也是 Vue 框架（类库）的基本架构图。由此看出，Vue 的实现，或者大部分 MVVM 的实现，就是我们本节课程介绍的概念组合应用。</p>
<p>关于框架的对比剖析，更多话题我们留在《第 4-7 课：从框架和类库，我们该学到什么》一课中介绍。</p>
<h3 id="揭秘虚拟-DOM"><a href="#揭秘虚拟-DOM" class="headerlink" title="揭秘虚拟 DOM"></a>揭秘虚拟 DOM</h3><p>我们来看现代框架中另一个重头戏——虚拟 DOM。虚拟 DOM 这个概念其实并没有那么新，甚至在前端三大框架问世之前，虚拟 DOM 就已经存在了，只不过<br>React 创造性的应用了虚拟 DOM，为前端发展带来了变革。Vue 2.0 也很快跟进，使得虚拟 DOM 彻底成为现代框架的重要基因。简单来说，虚拟<br>DOM 就是用数据结构表示 DOM 结构，它并没有真实 append 到 DOM 上，因此称之为“虚拟”。</p>
<p>应用虚拟 DOM 的收益也很直观：操作数据结构远比和浏览器交互去操作 DOM 快很多。请读者准确理解这句话：操作数据结构是指改变对象（虚拟<br>DOM），这个过程比修改真实 DOM 快很多。但虚拟 DOM 也最终是要挂载到浏览器上成为真实 DOM 节点，因此使用虚拟 DOM 并不能使得操作 DOM<br>的数量减少，但能够精确地获取最小的、最必要的操作 DOM 的集合。</p>
<p>这样一来，我们抽象表示 DOM，每次通过 DOM diff 计算出视图前后更新的最小差异，再去把最小差异应用到真实 DOM<br>上的做法，无疑更为可靠，性能更有保障。</p>
<p>那我们该如何表示虚拟 DOM 呢？又该如何产出虚拟 DOM 呢？</p>
<p>直观上我们看这样一段 DOM 结构：</p>
<pre><code>&lt;ul id=&quot;chapterList&quot;&gt;
  &lt;li class=&quot;chapter&quot;&gt;chapter1&lt;/li&gt;
  &lt;li class=&quot;chapter&quot;&gt;chapter2&lt;/li&gt;
  &lt;li class=&quot;chapter&quot;&gt;chapter3&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<p>如果用 JavaScript 来表示，我们采用对象结构：</p>
<pre><code>const chapterListVirtualDom = &#123;
  tagName: &#39;ul&#39;,
  attributes: &#123;
    id: &#39;chapterList&#39;
  &#125;,
  children: [
    &#123; tagName: &#39;li&#39;, attributes: &#123; class: &#39;chapter&#39; &#125;, children: [&#39;chapter1&#39;] &#125;,
    &#123; tagName: &#39;li&#39;, attributes: &#123; class: &#39;chapter&#39; &#125;, children: [&#39;chapter2&#39;] &#125;,
    &#123; tagName: &#39;li&#39;, attributes: &#123; class: &#39;chapter&#39; &#125;, children: [&#39;chapter3&#39;] &#125;,
  ]
&#125;</code></pre>
<p>很好理解：tagName 表示虚拟 DOM 对应的真实 DOM 标签类型；attributes 是一个对象，表示真实 DOM<br>节点上所有的属性；children 对应真实 DOM 的 childNodes，其中 childNodes 每一项又是类似的结构。</p>
<p>我们来实现一个虚拟 DOM 生成类，用于生产虚拟 DOM：</p>
<pre><code>class Element &#123;
  constructor(tagName, attributes = &#123;&#125;, children = []) &#123;
    this.tagName = tagName
    this.attributes = attributes
    this.children = children
  &#125;
&#125;

function element(tagName, attributes, children) &#123;
  return new Element(tagName, attributes, children)
&#125;</code></pre>
<p>上述虚拟 DOM 就可以这样生成：</p>
<pre><code>const chapterListVirtualDom = element(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter1&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter2&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter3&#39;])
])</code></pre>
<p>如图：</p>
<p><img src="https://images.gitbook.cn/23d3e7c0-925b-11e9-a0f8-2d0a45937cae" alt="enter image description
here"></p>
<p>是不是很简单？我们继续完成虚拟 DOM 向真实 DOM 节点的生成。首先实现一个 setAttribute 方法，后续的代码都将使用<br>setAttribute 方法来对 DOM 节点进行属性设置。</p>
<pre><code>const setAttribute = (node, key, value) =&gt; &#123;
  switch (key) &#123;
    case &#39;style&#39;:
      node.style.cssText = value
      break
    case &#39;value&#39;:
      let tagName = node.tagName || &#39;&#39;
      tagName = tagName.toLowerCase()
      if (
        tagName === &#39;input&#39; || tagName === &#39;textarea&#39;
      ) &#123;
        node.value = value
      &#125; else &#123;
        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性
        node.setAttribute(key, value)
      &#125;
      break
    default:
      node.setAttribute(key, value)
      break
  &#125;
&#125;</code></pre>
<p>Element 类中加入 render 原型方法，该方法的目的是根据虚拟 DOM 生成真实 DOM 片段：</p>
<pre><code>class Element &#123;
  constructor(tagName, attributes = &#123;&#125;, children = []) &#123;
    this.tagName = tagName
    this.attributes = attributes
    this.children = children
  &#125;

  render () &#123;
    let element = document.createElement(this.tagName)
    let attributes = this.attributes

     for (let key in attributes) &#123;
        setAttribute(element, key, attributes[key])
     &#125;

    let children = this.children

    children.forEach(child =&gt; &#123;
      let childElement = child instanceof Element
        ? child.render() // 若 child 也是虚拟节点，递归进行
        : document.createTextNode(child)  // 若是字符串，直接创建文本节点
      element.appendChild(childElement)
    &#125;)

    return element
  &#125;
&#125;

function element (tagName, attributes, children) &#123;
  return new Element(tagName, attributes, children)
&#125;</code></pre>
<p>实现也不困难，我们借助工具方法：setAttribute 进行属性的创建；对 children 每一项类型进行判断，如果是 Element<br>实例，进行递归调用 child 的 render 方法；直到遇见文本节点类型，进行内容渲染。</p>
<p>有了真实的 DOM 节点片段，我们趁热打铁，将真实的 DOM 节点渲染到浏览器上，实现 renderDOM 方法：</p>
<pre><code>const renderDom = (element, target) =&gt; &#123;
  target.appendChild(element)
&#125;</code></pre>
<p>执行代码：</p>
<pre><code>const setAttribute = (node, key, value) =&gt; &#123;
  switch (key) &#123;
    case &#39;style&#39;:
      node.style.cssText = value
      break
    case &#39;value&#39;:
      let tagName = node.tagName || &#39;&#39;
      tagName = tagName.toLowerCase()
      if (
        tagName === &#39;input&#39; || tagName === &#39;textarea&#39;
      ) &#123;
        node.value = value
      &#125; else &#123;
        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性
        node.setAttribute(key, value)
      &#125;
      break
    default:
      node.setAttribute(key, value)
      break
  &#125;
&#125;

class Element &#123;
  constructor(tagName, attributes = &#123;&#125;, children = []) &#123;
    this.tagName = tagName
    this.attributes = attributes
    this.children = children
  &#125;

  render () &#123;
    let element = document.createElement(this.tagName)
    let attributes = this.attributes

     for (let key in attributes) &#123;
        setAttribute(element, key, attributes[key])
     &#125;

    let children = this.children

    children.forEach(child =&gt; &#123;
      let childElement = child instanceof Element
        ? child.render() // 若 child 也是虚拟节点，递归进行
        : document.createTextNode(child)  // 若是字符串，直接创建文本节点
      element.appendChild(childElement)
    &#125;)

    return element
  &#125;
&#125;

function element (tagName, attributes, children) &#123;
  return new Element(tagName, attributes, children)
&#125;

const renderDom = (element, target) =&gt; &#123;
  target.appendChild(element)
&#125;

const chapterListVirtualDom = element(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter1&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter2&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter3&#39;])
])

const dom = chapterListVirtualDom.render()

renderDom(dom, document.body)</code></pre>
<p>得到如图：</p>
<p><img src="https://images.gitbook.cn/43b5d4e0-925b-11e9-a8e5-21b5567b38f4" alt="enter image description
here"></p>
<h4 id="虚拟-DOM-diff"><a href="#虚拟-DOM-diff" class="headerlink" title="虚拟 DOM diff"></a>虚拟 DOM diff</h4><p>有了上述基础，我们可以产出一份虚拟 DOM，并渲染在浏览器中。当用户在特定操作后，会产出新的一份虚拟 DOM，如何得出前后两份虚拟 DOM<br>的差异，并交给浏览器需要更新的结果呢？这就涉及到 DOM diff 的过程。</p>
<p>直观上，因为虚拟 DOM 是个树形结构，所以我们需要对两份虚拟 DOM 进行递归比较，将变化存储在一个变量 patches 中：</p>
<pre><code>const diff = (oldVirtualDom, newVirtualDom) =&gt; &#123;
    let patches = &#123;&#125;

    // 递归树，比较后的结果放到 patches
    walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)

     // 返回 diff 结果 
    return patches
&#125;</code></pre>
<p>walkToDiff 前两个参数是两个需要比较的虚拟 DOM 对象；第三个参数记录 nodeIndex，在删除节点时使用，初始为<br>0；第四个参数是一个闭包变量，记录 diff 结果：</p>
<pre><code>let initialIndex = 0

const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; &#123;
  let diffResult = []

  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
  if (!newVirtualDom) &#123;
    diffResult.push(&#123;
      type: &#39;REMOVE&#39;,
      index
    &#125;)
  &#125;
  // 如果新旧节点都是文本节点，是字符串
  else if (typeof oldVirtualDom === &#39;string&#39; &amp;&amp; typeof newVirtualDom === &#39;string&#39;) &#123;
    // 比较文本是否相同，如果不同则记录新的结果
    if (oldVirtualDom !== newVirtualDom) &#123;
      diffResult.push(&#123;
        type: &#39;MODIFY_TEXT&#39;,
        data: newVirtualDom,
        index
      &#125;)
    &#125;
  &#125;
  // 如果新旧节点类型相同
  else if (oldVirtualDom.tagName === newVirtualDom.tagName) &#123;
    // 比较属性是否相同
    let diffAttributeResult = &#123;&#125;

    for (let key in oldVirtualDom) &#123;
      if (oldVirtualDom[key] !== newVirtualDom[key]) &#123;
        diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    for (let key in newVirtualDom) &#123;
      // 旧节点不存在的新属性
      if (!oldVirtualDom.hasOwnProperty(key)) &#123;
          diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    if (Object.keys(diffAttributeResult).length &gt; 0) &#123;
        diffResult.push(&#123; 
          type: &#39;MODIFY_ATTRIBUTES&#39;, 
          diffAttributeResult 
        &#125;)
    &#125;

    // 如果有子节点，遍历子节点
    oldVirtualDom.children.forEach((child, index) =&gt; &#123;
      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
    &#125;)
  &#125;
  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
  else &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (!oldVirtualDom) &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (diffResult.length) &#123;
    patches[index] = diffResult
  &#125;
&#125;</code></pre>
<p>我们最后将所有代码放在一起：</p>
<pre><code>const setAttribute = (node, key, value) =&gt; &#123;
  switch (key) &#123;
    case &#39;style&#39;:
      node.style.cssText = value
      break
    case &#39;value&#39;:
      let tagName = node.tagName || &#39;&#39;
      tagName = tagName.toLowerCase()
      if (
        tagName === &#39;input&#39; || tagName === &#39;textarea&#39;
      ) &#123;
        node.value = value
      &#125; else &#123;
        // 如果节点不是 input 或者 textarea，则使用 setAttribute 去设置属性
        node.setAttribute(key, value)
      &#125;
      break
    default:
      node.setAttribute(key, value)
      break
  &#125;
&#125;

class Element &#123;
  constructor(tagName, attributes = &#123;&#125;, children = []) &#123;
    this.tagName = tagName
    this.attributes = attributes
    this.children = children
  &#125;

  render () &#123;
    let element = document.createElement(this.tagName)
    let attributes = this.attributes

     for (let key in attributes) &#123;
        setAttribute(element, key, attributes[key])
     &#125;

    let children = this.children

    children.forEach(child =&gt; &#123;
      let childElement = child instanceof Element
        ? child.render() // 若 child 也是虚拟节点，递归进行
        : document.createTextNode(child)  // 若是字符串，直接创建文本节点
      element.appendChild(childElement)
    &#125;)

    return element
  &#125;
&#125;

function element (tagName, attributes, children) &#123;
  return new Element(tagName, attributes, children)
&#125;

const renderDom = (element, target) =&gt; &#123;
  target.appendChild(element)
&#125;

const diff = (oldVirtualDom, newVirtualDom) =&gt; &#123;
  let patches = &#123;&#125;

  // 递归树 比较后的结果放到 patches
  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)

  return patches
&#125;

let initialIndex = 0

const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; &#123;
  let diffResult = []

  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
  if (!newVirtualDom) &#123;
    diffResult.push(&#123;
      type: &#39;REMOVE&#39;,
      index
    &#125;)
  &#125;
  // 如果新旧节点都是文本节点，是字符串
  else if (typeof oldVirtualDom === &#39;string&#39; &amp;&amp; typeof newVirtualDom === &#39;string&#39;) &#123;
    // 比较文本是否相同，如果不同则记录新的结果
    if (oldVirtualDom !== newVirtualDom) &#123;
      diffResult.push(&#123;
        type: &#39;MODIFY_TEXT&#39;,
        data: newVirtualDom,
        index
      &#125;)
    &#125;
  &#125;
  // 如果新旧节点类型相同
  else if (oldVirtualDom.tagName === newVirtualDom.tagName) &#123;
    // 比较属性是否相同
    let diffAttributeResult = &#123;&#125;

    for (let key in oldVirtualDom) &#123;
      if (oldVirtualDom[key] !== newVirtualDom[key]) &#123;
        diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    for (let key in newVirtualDom) &#123;
      // 旧节点不存在的新属性
      if (!oldVirtualDom.hasOwnProperty(key)) &#123;
          diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    if (Object.keys(diffAttributeResult).length &gt; 0) &#123;
        diffResult.push(&#123; 
          type: &#39;MODIFY_ATTRIBUTES&#39;, 
          diffAttributeResult 
        &#125;)
    &#125;

    // 如果有子节点，遍历子节点
    oldVirtualDom.children.forEach((child, index) =&gt; &#123;
      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
    &#125;)
  &#125;
  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
  else &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (!oldVirtualDom) &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (diffResult.length) &#123;
    patches[index] = diffResult
  &#125;
&#125;</code></pre>
<p>我们对 diff 进行测试：</p>
<pre><code>const chapterListVirtualDom = element(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter1&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter2&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter3&#39;])
])

const chapterListVirtualDom1 = element(&#39;ul&#39;, &#123; id: &#39;list2&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter4&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter5&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter6&#39;])
])

diff(chapterListVirtualDom, chapterListVirtualDom1)</code></pre>
<p>得到如图 diff 数组：</p>
<p><img src="https://images.gitbook.cn/6f1e0b70-925b-11e9-a0f8-2d0a45937cae"></p>
<h4 id="最小化差异应用"><a href="#最小化差异应用" class="headerlink" title="最小化差异应用"></a>最小化差异应用</h4><p>大功告成之前，我们来看看都做了哪些事情：通过 Element class 生成了虚拟 DOM，通过 diff 方法对任意两个虚拟 DOM<br>进行比对，得到差异。那么这个差异如何更新到现有的 DOM 节点中呢？看上去需要一个 patch 方法来完成：</p>
<pre><code>const patch = (node, patches) =&gt; &#123;
  let walker = &#123; index: 0 &#125;
  walk(node, walker, patches)
&#125;</code></pre>
<p>patch 方法接受一个真实的 DOM 节点，它是现有的浏览器中需要进行更新的 DOM 节点，同时接受一个最小化差异集合，该集合对接 diff<br>方法返回的结果。在 patch 方法内部，我们调用了 walk 函数：</p>
<pre><code>const walk = (node, walker, patches) =&gt; &#123;
  let currentPatch = patches[walker.index]

  let childNodes = node.childNodes

  childNodes.forEach(child =&gt; &#123;
    walker.index++
    walk(child, walker, patches)
  &#125;)

  if (currentPatch) &#123;
    doPatch(node, currentPatch)
  &#125;
&#125;</code></pre>
<p>walk 进行自身递归，对于当前节点的差异调用 doPatch 方法进行更新：</p>
<pre><code>const doPatch = (node, patches) =&gt; &#123;
  patches.forEach(patch =&gt; &#123;
    switch (patch.type) &#123;
      case &#39;MODIFY_ATTRIBUTES&#39;:
        const attributes = patch.diffAttributeResult.attributes
        for (let key in attributes) &#123;
            if (node.nodeType !== 1) return
            const value = attributes[key]
            if (value) &#123;
              setAttribute(node, key, value)
            &#125; else &#123;
              node.removeAttribute(key)
            &#125;
        &#125;
        break
      case &#39;MODIFY_TEXT&#39;:
        node.textContent = patch.data
        break
      case &#39;REPLACE&#39;:
        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)
        node.parentNode.replaceChild(newNode, node)
        break
      case &#39;REMOVE&#39;:
        node.parentNode.removeChild(node)
        break
      default:
        break
    &#125;
  &#125;)
&#125;</code></pre>
<p>doPatch 对四种类型的 diff 进行处理，最终进行测试：</p>
<pre><code>var element = chapterListVirtualDom.render()
renderDom(element, document.body)

const patches = diff(chapterListVirtualDom, chapterListVirtualDom1)

patch(element, patches)</code></pre>
<p>全部代码放在一起：</p>
<pre><code>const setAttribute = (node, key, value) =&gt; &#123;
  switch (key) &#123;
    case &#39;style&#39;:
      node.style.cssText = value
      break
    case &#39;value&#39;:
      let tagName = node.tagName || &#39;&#39;
      tagName = tagName.toLowerCase()
      if (
        tagName === &#39;input&#39; || tagName === &#39;textarea&#39;
      ) &#123;
        node.value = value
      &#125; else &#123;
        // 如果节点不是 input 或者 textarea, 则使用 setAttribute 去设置属性
        node.setAttribute(key, value)
      &#125;
      break
    default:
      node.setAttribute(key, value)
      break
  &#125;
&#125;

class Element &#123;
  constructor(tagName, attributes = &#123;&#125;, children = []) &#123;
    this.tagName = tagName
    this.attributes = attributes
    this.children = children
  &#125;

  render () &#123;
    let element = document.createElement(this.tagName)
    let attributes = this.attributes

     for (let key in attributes) &#123;
        setAttribute(element, key, attributes[key])
     &#125;

    let children = this.children

    children.forEach(child =&gt; &#123;
      let childElement = child instanceof Element
        ? child.render() // 若 child 也是虚拟节点，递归进行
        : document.createTextNode(child)  // 若是字符串，直接创建文本节点
      element.appendChild(childElement)
    &#125;)

    return element
  &#125;
&#125;

function element (tagName, attributes, children) &#123;
  return new Element(tagName, attributes, children)
&#125;

const renderDom = (element, target) =&gt; &#123;
  target.appendChild(element)
&#125;

const diff = (oldVirtualDom, newVirtualDom) =&gt; &#123;
  let patches = &#123;&#125;

  // 递归树 比较后的结果放到 patches
  walkToDiff(oldVirtualDom, newVirtualDom, 0, patches)

  return patches
&#125;

let initialIndex = 0

const walkToDiff = (oldVirtualDom, newVirtualDom, index, patches) =&gt; &#123;
  let diffResult = []

  // 如果 newVirtualDom 不存在，说明该节点被移除，我们将 type 为 REMOVE 的对象推进 diffResult 变量，并记录 index
  if (!newVirtualDom) &#123;
    diffResult.push(&#123;
      type: &#39;REMOVE&#39;,
      index
    &#125;)
  &#125;
  // 如果新旧节点都是文本节点，是字符串
  else if (typeof oldVirtualDom === &#39;string&#39; &amp;&amp; typeof newVirtualDom === &#39;string&#39;) &#123;
    // 比较文本是否相同，如果不同则记录新的结果
    if (oldVirtualDom !== newVirtualDom) &#123;
      diffResult.push(&#123;
        type: &#39;MODIFY_TEXT&#39;,
        data: newVirtualDom,
        index
      &#125;)
    &#125;
  &#125;
  // 如果新旧节点类型相同
  else if (oldVirtualDom.tagName === newVirtualDom.tagName) &#123;
    // 比较属性是否相同
    let diffAttributeResult = &#123;&#125;

    for (let key in oldVirtualDom) &#123;
      if (oldVirtualDom[key] !== newVirtualDom[key]) &#123;
        diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    for (let key in newVirtualDom) &#123;
      // 旧节点不存在的新属性
      if (!oldVirtualDom.hasOwnProperty(key)) &#123;
          diffAttributeResult[key] = newVirtualDom[key]
      &#125;
    &#125;

    if (Object.keys(diffAttributeResult).length &gt; 0) &#123;
        diffResult.push(&#123; 
          type: &#39;MODIFY_ATTRIBUTES&#39;, 
          diffAttributeResult 
        &#125;)
    &#125;

    // 如果有子节点，遍历子节点
    oldVirtualDom.children.forEach((child, index) =&gt; &#123;
      walkToDiff(child, newVirtualDom.children[index], ++initialIndex, patches)
    &#125;)
  &#125;
  // else 说明节点类型不同，被直接替换了，我们直接将新的结果 push
  else &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (!oldVirtualDom) &#123;
    diffResult.push(&#123; 
      type: &#39;REPLACE&#39;, 
      newVirtualDom
    &#125;)
  &#125;

  if (diffResult.length) &#123;
    patches[index] = diffResult
  &#125;
&#125;

const chapterListVirtualDom = element(&#39;ul&#39;, &#123; id: &#39;list&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter1&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter2&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter&#39; &#125;, [&#39;chapter3&#39;])
])

const chapterListVirtualDom1 = element(&#39;ul&#39;, &#123; id: &#39;list2&#39; &#125;, [
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter4&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter5&#39;]),
  element(&#39;li&#39;, &#123; class: &#39;chapter2&#39; &#125;, [&#39;chapter6&#39;])
])

const patch = (node, patches) =&gt; &#123;
  let walker = &#123; index: 0 &#125;
  walk(node, walker, patches)
&#125;

const walk = (node, walker, patches) =&gt; &#123;
  let currentPatch = patches[walker.index]

  let childNodes = node.childNodes

  childNodes.forEach(child =&gt; &#123;
    walker.index++
    walk(child, walker, patches)
  &#125;)

  if (currentPatch) &#123;
    doPatch(node, currentPatch)
  &#125;
&#125;

const doPatch = (node, patches) =&gt; &#123;
  patches.forEach(patch =&gt; &#123;
    switch (patch.type) &#123;
      case &#39;MODIFY_ATTRIBUTES&#39;:
        const attributes = patch.diffAttributeResult.attributes
        for (let key in attributes) &#123;
            if (node.nodeType !== 1) return
            const value = attributes[key]
            if (value) &#123;
              setAttribute(node, key, value)
            &#125; else &#123;
              node.removeAttribute(key)
            &#125;
        &#125;
        break
      case &#39;MODIFY_TEXT&#39;:
        node.textContent = patch.data
        break
      case &#39;REPLACE&#39;:
        let newNode = (patch.newNode instanceof Element) ? render(patch.newNode) : document.createTextNode(patch.newNode)
        node.parentNode.replaceChild(newNode, node)
        break
      case &#39;REMOVE&#39;:
        node.parentNode.removeChild(node)
        break
      default:
        break
    &#125;
  &#125;)
&#125;</code></pre>
<p>先执行：</p>
<pre><code>var element = chapterListVirtualDom.render()
renderDom(element, document.body)</code></pre>
<p>再执行：</p>
<pre><code>const patches = diff(chapterListVirtualDom, chapterListVirtualDom1)

patch(element, patches)</code></pre>
<p>生成结果符合预期。</p>
<p>短短不到两百行代码，就实现了虚拟 DOM 思想的全部流程。当然其中还有一些优化手段，一些边界情况并没有进行特别处理，但是我们去翻看一些著名的虚拟 DOM<br>库：snabbdom、etch 等，其实现思想和上述教例完全一致。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现代框架无疑极大程度上解放了前端生产力，其设计思想相互借鉴，存在非常多的共性。本讲我们通过分析前端框架中的共性，梳理概念原理，希望达到“任何一种框架变得不再神秘”的目的。掌握了这些基本思想，我们不仅能触类旁通，更快地上手框架，更能学习进阶，吸取优秀框架的精华。</p>
<h3 id="分享交流"><a href="#分享交流" class="headerlink" title="分享交流"></a>分享交流</h3><p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 <strong>你的分享不仅帮助他人，更会提升自己。</strong></p>
<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>
<blockquote>
<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-<br>泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/advanced/017--%E8%A7%A6%E7%B1%BB%E6%97%81%E9%80%9A%E5%A4%9A%E7%A7%8D%E6%A1%86%E6%9E%B6/">https://jinxiaochuan.github.io/matrix/advanced/017--%E8%A7%A6%E7%B1%BB%E6%97%81%E9%80%9A%E5%A4%9A%E7%A7%8D%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/advanced/036--%E4%BB%A5%20React%20%E4%B8%BA%E4%BE%8B%EF%BC%8C%E8%AF%B4%E8%AF%B4%E6%A1%86%E6%9E%B6%E5%92%8C%E6%80%A7%E8%83%BD%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶36 | 以 React 为例，说说框架和性能（上）</div></div></a></div><div class="next-post pull-right"><a href="/matrix/advanced/027--webpack%20%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%92%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E4%B8%8B%EF%BC%89/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶27 | webpack 工程师和前端工程师（下）</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="this.onerror=null;this.src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E6%A1%86%E6%9E%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">响应式框架基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E4%B8%8E%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.</span> <span class="toc-text">数据劫持与代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">监听数组变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-defineProperty-VS-Proxy"><span class="toc-number">1.3.</span> <span class="toc-text">Object.defineProperty VS Proxy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.</span> <span class="toc-text">模版编译原理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E7%89%88%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.</span> <span class="toc-text">模版编译实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">双向绑定实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">发布订阅模式简单应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM-%E8%9E%8D%E4%BC%9A%E8%B4%AF%E9%80%9A"><span class="toc-number">4.</span> <span class="toc-text">MVVM 融会贯通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%AD%E7%A7%98%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">5.</span> <span class="toc-text">揭秘虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM-diff"><span class="toc-number">5.1.</span> <span class="toc-text">虚拟 DOM diff</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%96%E5%B7%AE%E5%BC%82%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">最小化差异应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81"><span class="toc-number">7.</span> <span class="toc-text">分享交流</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/algorithm/" title="FE Algorithm - 阶乘"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-1ef0181f71fe1bd731f172ff3b0fc2d3_1200x500.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611282995&amp;t=42ae5101c61f264a349c808013a9c512" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶38 | 揭秘前端设计模式（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）">核心进阶38 | 揭秘前端设计模式（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）">核心进阶47 | 缓存谁都懂，一问都哑巴（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶49 | HTTP 的深思：我从何而来，去向何处"/></a><div class="content"><a class="title" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处">核心进阶49 | HTTP 的深思：我从何而来，去向何处</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶51 | 大话社区和一名技术者的自我修养"/></a><div class="content"><a class="title" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养">核心进阶51 | 大话社区和一名技术者的自我修养</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>