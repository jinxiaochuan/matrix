<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶45 | 分析一道“微信”面试题 | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。 网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。 本讲知识点如下：  题意分析我们来先看看题目：  实现一个 LazyMan，按照以下方式调用时，得到相关输出：">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶45 | 分析一道“微信”面试题">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/advanced/045--%E5%88%86%E6%9E%90%E4%B8%80%E9%81%93%E2%80%9C%E5%BE%AE%E4%BF%A1%E2%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。 网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。 本讲知识点如下：  题意分析我们来先看看题目：  实现一个 LazyMan，按照以下方式调用时，得到相关输出：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360">
<meta property="article:published_time" content="2020-12-23T03:47:50.496Z">
<meta property="article:modified_time" content="2020-12-23T03:47:50.496Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/advanced/045--%E5%88%86%E6%9E%90%E4%B8%80%E9%81%93%E2%80%9C%E5%BE%AE%E4%BF%A1%E2%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-23 11:47:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="onerror=null;src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶45 | 分析一道“微信”面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-23T03:47:50.496Z" title="更新于 2020-12-23 11:47:50">2020-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>前一段时间，一道疑似“微信”招聘的面试题出现，可能有不少读者已经了解过了。这道题乍一看挺难，但是细细分析却还算简单，我们甚至可以用多种手段解题，用不同思想来给出答案。</p>
<p>网上零零碎碎的有一些解答，但是缺乏全面梳理。我认为通过这道题，有必要将前端多重知识点“融会贯通”，在这里和大家分享。</p>
<p>本讲知识点如下：</p>
<p><img src="https://images.gitbook.cn/bfedc2e0-de9e-11e9-9f8b-d5f483bb0ebd" alt="enter image description
here"></p>
<h3 id="题意分析"><a href="#题意分析" class="headerlink" title="题意分析"></a>题意分析</h3><p>我们来先看看题目：</p>
<blockquote>
<p>实现一个 LazyMan，按照以下方式调用时，得到相关输出：</p>
</blockquote>
<pre><code>LazyMan(&quot;Hank&quot;)
// Hi! This is Hank!
 
LazyMan(&quot;Hank&quot;).sleep(10).eat(&quot;dinner&quot;)
// Hi! This is Hank!
// 等待10 秒..
// Wake up after 10
// Eat dinner~
 
LazyMan(&quot;Hank&quot;).eat(&quot;dinner&quot;).eat(&quot;supper&quot;)
// Hi This is Hank!
// Eat dinner~
// Eat supper~
 
LazyMan(&quot;Hank&quot;).sleepFirst(5).eat(&quot;supper&quot;)
// 等待 5 秒
// Wake up after 5
// Hi This is Hank!
// Eat supper</code></pre>
<p>当面试者拿到这道题目的时候，乍看题干可能会有点慌张。其实很多面试失败是“自己吓唬自己”，在平时放松状态下写代码，也许解题不在话下。</p>
<p>下面我们就从接到题目开始，剖析应该如何进行分析：</p>
<ul>
<li>可以把 LazyMan 理解为一个构造函数，在调用时输出参数内容</li>
<li>LazyMan 支持链式调用</li>
<li>链式调用过程提供了以下几个方法：sleepFirst、eat、sleep</li>
<li>其中 eat 方法输出参数相关内容：Eat + 参数</li>
<li>sleep 方法比较特殊，链式调用将暂停一定时间后继续执行，看到这里也许应该想到 setTimeout</li>
<li>sleepFirst 最为特殊，这个任务或者这个方法的 <strong>优先级最高</strong> ；调用 sleepFirst 之后，链式调用将暂停一定时间后继续执行。请再次观察题干，尤其是最后一个 demo，sleepFirst 的输出优先级最高，调用后先等待 5 秒输出 Wake up after 5，再输出 Hi This is Hank!</li>
</ul>
<p>我们应该如何解这个题目呢，从拿到需求开始进行分析：</p>
<ul>
<li>先从最简单的，我们可以封装一些基础方法，比如 log 输出、封装 setTimeout 等</li>
<li>因为 LazyMan 要实现一系列调用， <strong>且调用并不是顺序执行的，比如如果 sleepFirst 出现在调用链时，优先执行；同时任务并不是全部都同步执行的</strong> ，因此 <strong>我们应该实现一个任务队列</strong> ，这个队列将调度执行各个任务</li>
<li>因此每次调用 LazyMan 或链式执行时，我们应该将相关调用方法加入到（push）任务队列中，储存起来，后续统一被调度</li>
<li>在写入任务队列时，如果当前的方法为 sleepFirst，那么需要将该方法放到队列的最头处，这应该是一个 unshift 方法</li>
</ul>
<p>这么一分析，这道题就“非常简单”了。</p>
<p>我们来试图解剖一下这道题目的考察点：</p>
<ul>
<li>面向对象思想与设计，包括类的使用等</li>
<li>对象方法链式调用的理解和设计</li>
<li>小部分设计模式的设计</li>
<li>因为存在“重复逻辑”，考察代码的解耦和抽象能力</li>
<li>逻辑的清晰程度以及其他编程思维</li>
</ul>
<h3 id="常规思路解答"><a href="#常规思路解答" class="headerlink" title="常规思路解答"></a>常规思路解答</h3><p>基于以上思路，我们给出较为常规的答案，其中代码已经加上了必要的注释：</p>
<pre><code>class LazyManGenerator &#123;
  constructor(name) &#123;
    this.taskArray = []

    // 初始化时任务
    const task = () =&gt; &#123;
      console.log(`Hi! This is $&#123;name&#125;`)
      // 执行完初始化时任务后，继续执行下一个任务
      this.next()
    &#125;

    // 将初始化任务放入任务队列中
    this.taskArray.push(task)

    setTimeout(() =&gt; &#123;
      this.next()
    &#125;, 0)
  &#125;

  next() &#123;
      // 取出下一个任务并执行
    const task = this.taskArray.shift()
    task &amp;&amp; task()
  &#125;

  sleep(time) &#123;
    this.sleepTask(time, false)
    // return this 保持链式调用
    return this
  &#125;

  sleepFirst(time) &#123;
    this.sleepTask(time, true)
    return this
  &#125;

  sleepTask(time, prior) &#123;
    const task = () =&gt; &#123;
      setTimeout(() =&gt; &#123;
        console.log(`Wake up after $&#123;time&#125;`)
        this.next()
      &#125;, time * 1000)
    &#125;

    if (prior) &#123;
      this.taskArray.unshift(task)
    &#125; else &#123;
      this.taskArray.push(task)
    &#125;
  &#125;

  eat(name) &#123;
    const task = () =&gt; &#123;
      console.log(`Eat $&#123;name&#125;`)
      this.next()
    &#125;

    this.taskArray.push(task)
    return this
  &#125;
&#125;

function LazyMan(name) &#123;
  return new LazyManGenerator(name)
&#125;</code></pre>
<p>简单分析一下：</p>
<ul>
<li>LazyMan 方法返回一个 LazyManGenerator 构造函数的实例</li>
<li>在 LazyManGenerator constructor 当中，我们维护了 taskArray 用来存储任务，同时将初始化任务放到 taskArray 当中</li>
<li>还是在 LazyManGenerator constructor 中，将任务的逐个执行即 next 调用放在 setTimeout 中，这样就能够保证在开始执行任务时，taskArray 数组已经填满了任务</li>
<li>我们来看看 next 方法，取出 taskArray 数组中的首项，进行执行</li>
<li>eat 方法将 eat task 放到 taskArray 数组中，注意 eat task 方法需要调用 this.next() 显式调用“下一个任务”；同时返回 this，完成链式调用</li>
<li>sleep 和 sleepFirst 都调用了 sleepTask，不同在于第二个参数：sleepTask 第二个参数表示是否优先执行，如果 prior 为 true，则使用 unshift 将任务插到 taskArray 开头</li>
</ul>
<p>这个解法最容易想到，也相对来说容易，主要是面向过程。关键点在于对于 setTimeout 任务队列的准确理解以及 return this<br>实现链式调用的方式。</p>
<p>事实上，sleepTask 应该作为 LazyManGenerator 类的私有属性出现，因为 ES class 暂时 private<br>属性没有被广泛实现，这里不再追求实现。</p>
<h3 id="设计模式解答"><a href="#设计模式解答" class="headerlink" title="设计模式解答"></a>设计模式解答</h3><p>关于这道题目的解答，网上最流行的是一种发布订阅模式的方案。相关代码出处：[lazyMan](<a target="_blank" rel="noopener" href="https://github.com/wall-">https://github.com/wall-</a><br>wxk/blogDemo/blob/master/2017/01/22/lazyMan.html)。</p>
<p>但是其实仔细看其实现，也是上一环节中常规解法的变种。虽然说是发布订阅模式，但是其实仍然是 next 思想执行下一个任务的思路，该实现 publish 和<br>subscribe 方法分别是完成执行任务和注册任务逻辑。我认为这样的代码实现有一点“过度设计”之嫌，更像是往发布订阅模式上去靠，整体流程不够自然。</p>
<p>当然读者仍可参考，并有自己的思考，这里我不再更多分析。</p>
<h3 id="再谈流程控制和队列、中间件启发"><a href="#再谈流程控制和队列、中间件启发" class="headerlink" title="再谈流程控制和队列、中间件启发"></a>再谈流程控制和队列、中间件启发</h3><p>这道题目我们给出解法并不算完，更重要也更有价值的是思考、延伸。微信题目较好地考察了候选者的流程控制能力，而流程控制在前端开发者面前也非常重要。</p>
<p>我们看上述代码中的 next 函数，它负责找出 stack 中的下一个函数并执行：</p>
<pre><code>next() &#123;
    // 取出下一个任务并执行
    const task = this.taskArray.shift()
    task &amp;&amp; task()
&#125;</code></pre>
<p>NodeJS 中 connect 类库，以及其他框架的中间件设计也都离不开类似思想的 next。比如生成器自动执行函数 co、redux、koa<br>也通过不同的实现，可以让 next 在多个函数之间执行完后面的函数再折回来执行 next，较为巧妙。我们具体来看一下。</p>
<h4 id="senchalabs-connect-和-express"><a href="#senchalabs-connect-和-express" class="headerlink" title="senchalabs connect 和 express"></a>senchalabs connect 和 express</h4><p>具体场景：在 Node 环境中，有 parseBody、checkIdInDatabase 等相关中间件，他们组成了 middlewares 数组：</p>
<pre><code>const middlewares = [
  function middleware1(req, res, next) &#123;
    parseBody(req, function(err, body) &#123;
      if (err) return next(err);
      req.body = body;
      next();
    &#125;);
  &#125;,
  function middleware2(req, res, next) &#123;
    checkIdInDatabase(req.body.id, function(err, rows) &#123;
      if (err) return next(err);
      res.dbResult = rows;
      next();
    &#125;);
  &#125;,
  function middleware3(req, res, next) &#123;
    if (res.dbResult &amp;&amp; res.dbResult.length &gt; 0) &#123;
      res.end(&#39;true&#39;);
    &#125;
    else &#123;
      res.end(&#39;false&#39;);
    &#125;
    next();
  &#125;
]</code></pre>
<p>当一个请求打开时，我们需要链式调用各个中间件：</p>
<pre><code>const requestHandler = (req, res) =&gt; &#123;
  let i = 0

  function next(err) &#123;
    if (err) &#123;
      return res.end(&#39;error:&#39;, err.toString())
    &#125;

    if (i &lt; middlewares.length) &#123;
      middlewares[i++](req, res, next)
    &#125; else &#123;
      return
    &#125;
  &#125;

  // 初始执行第一个中间件
  next()
&#125;</code></pre>
<p>基本思路和面试题解法一致：</p>
<ul>
<li>将所有中间件（任务处理函数）储存在一个 list 中</li>
<li>循环依次调用中间件（任务处理函数）</li>
</ul>
<p>senchalabs/connect 这个库做了很好的封装，是 express 等框架设计实现的原始模型。这里我们简单分析一下<br>senchalabs/connect 这个库的实现。</p>
<p>用法：</p>
<p>首先使用 createServer 方法创建 app 实例，</p>
<pre><code>const app = createServer()</code></pre>
<p>对应源码：</p>
<pre><code>function createServer() &#123;
  function app(req, res, next)&#123; app.handle(req, res, next); &#125;
  merge(app, proto);
  merge(app, EventEmitter.prototype);
  app.route = &#39;/&#39;;
  app.stack = [];
  return app;
&#125;</code></pre>
<p>我们看 app 实例“继承”了 EventEmitter 类，实现事件发布订阅，同时 stack 数组来维护各个中间件任务。</p>
<p>接着使用 app.use 来添加中间件：</p>
<pre><code>app.use(&#39;/api&#39;, function(req, res, next) &#123;//...&#125;)</code></pre>
<p>源码实现：</p>
<pre><code>proto.use = function use(route, fn) &#123;
  var handle = fn;
  var path = route;

  // default route to &#39;/&#39;
  if (typeof route !== &#39;string&#39;) &#123;
    handle = route;
    path = &#39;/&#39;;
  &#125;

  // wrap sub-apps
  if (typeof handle.handle === &#39;function&#39;) &#123;
    var server = handle;
    server.route = path;
    handle = function (req, res, next) &#123;
      server.handle(req, res, next);
    &#125;;
  &#125;

  // wrap vanilla http.Servers
  if (handle instanceof http.Server) &#123;
    handle = handle.listeners(&#39;request&#39;)[0];
  &#125;

  // strip trailing slash
  if (path[path.length - 1] === &#39;/&#39;) &#123;
    path = path.slice(0, -1);
  &#125;

  // add the middleware
  debug(&#39;use %s %s&#39;, path || &#39;/&#39;, handle.name || &#39;anonymous&#39;);
  this.stack.push(&#123; route: path, handle: handle &#125;);

  return this;
&#125;;</code></pre>
<p>通过 if…else 逻辑区分出三种不同的 fn 类型：</p>
<ul>
<li>fn 是一个普通的 function(req,res[,next]){} 函数</li>
<li>fn 是一个普通的 httpServer</li>
<li>fn 是一个普通的是另一个 connect 的 app 对象（sub app 特性）</li>
</ul>
<p>对于这三种类型，分别转换为 function(req, res, next) {} 的形式，具体我们不再分析。最重要的执行过程是：</p>
<pre><code>this.stack.push(&#123; route: path, handle: handle &#125;)</code></pre>
<p>以及返回：</p>
<pre><code>return this</code></pre>
<p>以上就完成了中间件即任务的注册，我们有：</p>
<pre><code>app.stack = [function1, function2, function3, ...];</code></pre>
<p>接下来看看任务的调度和执行。使用方法：</p>
<pre><code>app.handle(req, res, out)</code></pre>
<p>handle 源码实现：</p>
<pre><code>proto.handle = function handle(req, res, out) &#123;
  var index = 0;
  var protohost = getProtohost(req.url) || &#39;&#39;;
  var removed = &#39;&#39;;
  var slashAdded = false;
  var stack = this.stack;

  // final function handler
  var done = out || finalhandler(req, res, &#123;
    env: env,
    onerror: logerror
  &#125;);

  // store the original URL
  req.originalUrl = req.originalUrl || req.url;

  function next(err) &#123;
    // ...
  &#125;

  next();
&#125;;</code></pre>
<p>源码导读：out 参数是关于 sub app 的特性，这个特性可以暂时忽略，我们暂时不关心。handle 实现我们并不陌生，它构建 next<br>函数，并触发第一个 next 执行。</p>
<p>next 实现：</p>
<pre><code>function next(err) &#123;
    if (slashAdded) &#123;
      req.url = req.url.substr(1);
      slashAdded = false;
    &#125;

    if (removed.length !== 0) &#123;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = &#39;&#39;;
    &#125;

    // next callback
    var layer = stack[index++];

    // all done
    if (!layer) &#123;
      defer(done, err);
      return;
    &#125;

    // route data
    var path = parseUrl(req).pathname || &#39;/&#39;;
    var route = layer.route;

    // skip this layer if the route doesn&#39;t match
    if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) &#123;
      return next(err);
    &#125;

    // skip if route match does not border &quot;/&quot;, &quot;.&quot;, or end
    var c = path.length &gt; route.length &amp;&amp; path[route.length];
    if (c &amp;&amp; c !== &#39;/&#39; &amp;&amp; c !== &#39;.&#39;) &#123;
      return next(err);
    &#125;

    // trim off the part of the url that matches the route
    if (route.length !== 0 &amp;&amp; route !== &#39;/&#39;) &#123;
      removed = route;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      // ensure leading slash
      if (!protohost &amp;&amp; req.url[0] !== &#39;/&#39;) &#123;
        req.url = &#39;/&#39; + req.url;
        slashAdded = true;
      &#125;
    &#125;

    // call the layer handle
    call(layer.handle, route, err, req, res, next);
&#125;</code></pre>
<p>源码导读：</p>
<ul>
<li>取出下一个中间件</li>
</ul>
<pre><code>var layer = stack[index++]</code></pre>
<ul>
<li>如果当前请求路由和 handler 不匹配，则跳过：</li>
</ul>
<pre><code>if (path.toLowerCase().substr(0, route.length) !== route.toLowerCase()) &#123;
  return next(err);
&#125;</code></pre>
<ul>
<li>若匹配，则执行 call 函数，call 函数实现：</li>
</ul>
<pre><code>function call(handle, route, err, req, res, next) &#123;
  var arity = handle.length;
  var error = err;
  var hasError = Boolean(err);

  debug(&#39;%s %s : %s&#39;, handle.name || &#39;&lt;anonymous&gt;&#39;, route, req.originalUrl);

  try &#123;
    if (hasError &amp;&amp; arity === 4) &#123;
      // error-handling middleware
      handle(err, req, res, next);
      return;
    &#125; else if (!hasError &amp;&amp; arity &lt; 4) &#123;
      // request-handling middleware
      handle(req, res, next);
      return;
    &#125;
  &#125; catch (e) &#123;
    // replace the error
    error = e;
  &#125;

  // continue
  next(error);
&#125;</code></pre>
<p>注意：我们使用了 try…catch 包裹逻辑，这是很必要的容错思维，这样第三方中间件的执行如果出错，不至于打挂我们的应用。</p>
<p>较为巧妙的一点是：function(err, req, res, next){} 形式为错误处理函数，function(req, res, next){}<br>为正常的业务逻辑处理函数。因此通过 Function.length 来判断当前 handler 是否为容错函数，来做到参数的传入。</p>
<p>call 函数是 next 函数的核心，它是一个执行者，并在最后的逻辑中继续执行 next 函数，完成中间件的顺序调用。</p>
<p>NodeJS 的框架 express，实际就是 senchalabs connect 的升级版，通过对 connect<br>源码的学习，我们应该更加清楚流程的调度和控制，再去看 express 就轻而易举了。</p>
<p>Senchalabs connect 用流程控制库的回调函数及中间件的思想来解耦回调逻辑；Koa 则是用generator 方法解决回调问题（最新版使用<br>async/await）。事实上，也可以用事件、Promise 的方式实现，下一环节，我们就分析 Koa 的洋葱模型。</p>
<h4 id="Koa-的洋葱模型"><a href="#Koa-的洋葱模型" class="headerlink" title="Koa 的洋葱模型"></a>Koa 的洋葱模型</h4><p>对 Koa 中间的洋葱模型的分析文章上不少，著名的洋葱圈图示我也不在自己画了，具体使用不再介绍，不了解的读者请先自行学习。</p>
<p>我想先谈一下面向切面编程（AOP），在 JavaScript 语言为例，一个简单的示例：</p>
<pre><code>Function.prorotype.before = function (fn) &#123;
  const self = this
  return function (...args) &#123;
    console.log(&#39;&#39;)
    let res = fn.call(this)
    if (res) &#123;
      self.apply(this, args)
    &#125;
  &#125;
&#125;

Function.prototype.after = function (fn) &#123;
  const self = this
  return function (...args) &#123;
    let res = self.apply(this, args)
    if (res) &#123;
      fn.call(this)
    &#125;
  &#125;
&#125;</code></pre>
<p>这样的代码实现，是我们能够在执行某个函数 fn 之前，先执行某段逻辑；在某个函数 fn<br>之后，再去执行另一段逻辑。其实是一种简单中间件流程控制的体现。不过这样的 AOP 有一个问题：无法实现异步模式。</p>
<p>那么如何实现 Koa 的异步中间件模式呢？即某个中间件执行到一半，交出执行权，之后再回来继续执行。我们直接看源码分析，这段源码实现了 Koa<br>洋葱模型中间件：</p>
<pre><code>function compose(middleware) &#123;
  return function *(next) &#123;(
    if (!next) next = noop();

    var i = middleware.length;

    while (i--) &#123;
      next = middleware[i].call(this, next);
      console.log(&#39;isGenerator:&#39;, (typeof next.next === &#39;function&#39; &amp;&amp; typeof next.throw === &#39;function&#39;)); // true
    &#125;

    return yield *next;
  &#125;
&#125;

function *noop()&#123;&#125;</code></pre>
<p>其中，一个中间件的写法类似：</p>
<pre><code>app.use(function *(next)&#123;
  var start = new Date;
  yield next;
  var ms = new Date - start;
  this.set(&#39;X-Response-Time&#39;, ms + &#39;ms&#39;);
&#125;);</code></pre>
<p>这是一个很简单的记录 response time 的中间件，中间件跳转的信号是 yield next。</p>
<p>较新版本的 Koa 已经改用 async/await 实现，思路也是完全一样的，当然看上去更加优雅：</p>
<pre><code>function compose (middleware) &#123;
  if (!Array.isArray(middleware)) throw new TypeError(&#39;Middleware stack must be an array!&#39;)
  for (const fn of middleware) &#123;
    if (typeof fn !== &#39;function&#39;) throw new TypeError(&#39;Middleware must be composed of functions!&#39;)
  &#125;

  return function (context, next) &#123;
    let index = -1
    return dispatch(0)

    function dispatch (i) &#123;
      if (i &lt;= index) return Promise.reject(new Error(&#39;next() called multiple times&#39;))
      index = i
      let fn = middleware[i]
      if (i === middleware.length) &#123;
        fn = next
      &#125;
      if (!fn) return Promise.resolve()
      try &#123;
        return Promise.resolve(fn(context, function next () &#123;
          return dispatch(i + 1)
        &#125;))
      &#125; catch (err) &#123;
        return Promise.reject(err)
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>我们来重点解读一下这个版本的实现：</p>
<ul>
<li>compose 传入的 middleware 参数必须是数组，否则抛出错误</li>
<li>middleware 数组的每一个元素必须是函数，否则抛出错误</li>
<li>compose 返回一个函数，保存对 middleware 的引用</li>
<li>compose 返回函数的第一个参数是 context，所有中间件的第一个参数就是传入的 context</li>
<li>compose 返回函数的第二个参数是 next 函数，next 是实现洋葱模型的关键</li>
<li>index 记录当前运行到第几个中间件</li>
<li>执行第一个中间件函数：return dispatch(0)</li>
<li>dispatch 函数中，参数 i 如果小于等于 index，说明一个中间件中执行了多次 next，我们进行报错，由此可见一个中间件函数内部不允许多次调用 next 函数</li>
<li>取出中间件函数 fn = middleware[i]</li>
<li>如果 i === middleware.length，说明执行到了圆心，将 next 赋值给 fn</li>
<li>因为 async 需要后面是 Promise，我们包一层 Promise</li>
<li>next 函数是固定的，它可以执行下一个中间件函数</li>
</ul>
<pre><code>function next () &#123;
  return dispatch(i + 1)
&#125;</code></pre>
<p>如果读者不好理解，可以参考应用示例：</p>
<pre><code>async function middleware1(ctx, next) &#123;
  console.log(&#39;1&#39;)
  await next()
  console.log(&#39;2&#39;)
&#125;;

async function middleware2(ctx, next) &#123;
  console.log(&#39;3&#39;)
  await next()
  console.log(&#39;4&#39;)
&#125;;</code></pre>
<p>如果读者还是难以理解，我给出一个简版逻辑：</p>
<pre><code>function compose (middleware) &#123;
  return dispatch(0) 
  function dispatch(i) &#123;
    fn = middleware[i]
    if(!fn) return
    return fn(() =&gt; dispatch(i + 1))
  &#125;
&#125;</code></pre>
<h4 id="co-库不再神秘"><a href="#co-库不再神秘" class="headerlink" title="co 库不再神秘"></a>co 库不再神秘</h4><p>说到流程控制，也少不了大名鼎鼎的 co 库。co 函数库是 TJ 大神基于 ES6 generator 的异步解决方案，因此这里需要读者熟练掌握 ES6<br>generator。目前虽然 co 库可能不再“流行”，但是了解其实现，模拟类似场景也是非常有必要的。</p>
<p>我们这里不解读其源码，而是实现一个类似的自动执行 generator 的方案：</p>
<pre><code>const runGenerator = generatorFunc =&gt; &#123;
  const it = generatorFunc()
  iterate(it)

  function iterate (it) &#123;
    step()

    function step(arg, isError) &#123;
      const &#123;value, done&#125; = isError ? it.throw(arg) : it.next(arg)

      let response

      if (!done) &#123;
        if (typeof value === &#39;function&#39;) &#123;
          response = value() 
        &#125; else &#123;
          response = value  
        &#125;

        Promise.resolve(response).then(step, err =&gt; step(err, true))
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>代码解读：</p>
<ul>
<li>runGenerator 函数接受一个生成器函数 generatorFunc</li>
<li>运行 generatorFunc 得到结果，并通过 iterate 函数，迭代该生成器结果</li>
<li>iterate 函数中执行 step 函数，step 函数的第一个参数 arg 是上一个 yield 右表达式的“求出的值”，即下面对应的 response</li>
<li>这里需要考虑 response 的求值过程，它通过 value 计算得来，value 是 yield 右侧的值，它有这么几种情况：</li>
<li>yield new Promise()，value 是一个 promise 实例，那么 response 就是该 Promise 实例 resolve 后的值</li>
<li>yield () =&gt; {return value}，value 是一个函数，那么 response 就是执行该函数后的返回值</li>
<li>yield value，value 是一个普通值，那么 response 就是该值</li>
<li>我们最终统一利用 Promise.resolve 的特性，对 response 进行处理，并递归（迭代）调用 step</li>
<li>同时利用 step 函数 arg 参数，赋值给上一个 yield 的左表达式值，并返回下一个 yield 右表达式的值</li>
</ul>
<p>执行代码：</p>
<pre><code>function* gen1() &#123;
  yield console.log(1)
  yield console.log(2)
  yield console.log(3)
&#125;

runGenerator(gen1)</code></pre>
<p>或者：</p>
<pre><code>function* gen2() &#123;
  var value1 = yield Promise.resolve(&#39;promise&#39;)
  console.log(value1)

  var value2 = yield () =&gt; Promise.resolve(&#39;thunk&#39;)      
  console.log(value2)

  var value3 = yield 2
  console.log(value3)
&#125;

 runGenerator(gen2);</code></pre>
<p>最后还是附上 co 的实现：</p>
<pre><code>function co(gen) &#123; // co 接受一个 generator 函数
    var ctx = this
    var args = slice.call(arguments, 1)

    return new Promise(function(resolve, reject) &#123; // co 返回一个 Promise 对象
        if(typeof gen === &#39;function&#39;) gen = gen.apply(ctx, args) // gen 为 generator 函数，执行该函数
        if(!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen) // 不是则返回并更新 Promise状态为 resolve

        onFulfilled() // 将generator 函数的 next 方法包装成 onFulfilled，主要是为了能够捕获抛出的异常

        /**
          * @param &#123;Mixed&#125; res
          * @return &#123;Promise&#125;
          * @api private
         */
        function onFulfilled(res) &#123;
            var ret;
            try &#123;
                ret = gen.next(res)
            &#125; catch (err) &#123;
                return reject(err)
            &#125;
            next(ret)
        &#125;

        /**
          * @param &#123;Error&#125; err
          * @return &#123;Promise&#125;
          * @api private
         */
        function onRejected(err) &#123;
            var ret
            try &#123;
                ret = gen.throw(err)
            &#125; catch (err) &#123;
                return reject(err)
            &#125;
            next(ret)
        &#125;

        /**
          * Get the next value in the generator,
         * return a promise.
         *
         * @param &#123;Object&#125; ret
         * @return &#123;Promise&#125;
         * @api private
         */
        function next(ret) &#123;
            if(ret.done) return resolve(ret.value)
            var value = toPromise.call(ctx, ret.value) // if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
            if(value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected)
            return onRejected(new TypeError(&#39;You may only yield a function, promise, generator, but the following object was passed: &#39; + String(ret.value) + &#39;&quot;&#39;))
        &#125;
    &#125;)
&#125;</code></pre>
<p>如果读者对于以上内容理解有困难，那么我建议还是从 generator 等最基本的概念切入，不必心急，慢慢反复体会。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这道“著名”的“微信”面试题，绝不只是网上分析的几行代码答案那么简单，本讲我们从这道题目出发，分析了几种解决方案。更重要的是，在解决方案的基础上，我们重点剖析了<br>JavaScript 处理任务流程、控制触发逻辑的方方面面。也许在小型传统页面应用中，这样“相对复杂”的处理场景并不多见，但是在大型项目、富交互项目、后端<br>NodeJS 中非常重要，尤其是中间件思想、洋葱模型是非常典型的编程思路，希望读者能认真体会。</p>
<p>最后我们分析了 generator 以及 Koa 中间件实现原理，也许读者在平时基础业务开发中接触不到这些知识，但是请想一想 redux-saga<br>的实现、中间件的编写，其实都是这些内容运用体现。进阶即是如此，如果不掌握好这些“难啃”的知识，那么永远无法写出优秀的框架和解决方案。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/advanced/045--%E5%88%86%E6%9E%90%E4%B8%80%E9%81%93%E2%80%9C%E5%BE%AE%E4%BF%A1%E2%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/">https://jinxiaochuan.github.io/matrix/advanced/045--%E5%88%86%E6%9E%90%E4%B8%80%E9%81%93%E2%80%9C%E5%BE%AE%E4%BF%A1%E2%80%9D%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/advanced/044--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶44 | 那些年常考的前端算法（下）</div></div></a></div><div class="next-post pull-right"><a href="/matrix/advanced/048--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8B%EF%BC%89/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶48 | 缓存谁都懂，一问都哑巴（下）</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="this.onerror=null;this.src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E6%84%8F%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">题意分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF%E8%A7%A3%E7%AD%94"><span class="toc-number">2.</span> <span class="toc-text">常规思路解答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%A7%A3%E7%AD%94"><span class="toc-number">3.</span> <span class="toc-text">设计模式解答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E8%B0%88%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E9%98%9F%E5%88%97%E3%80%81%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%90%AF%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">再谈流程控制和队列、中间件启发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#senchalabs-connect-%E5%92%8C-express"><span class="toc-number">4.1.</span> <span class="toc-text">senchalabs connect 和 express</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Koa-%E7%9A%84%E6%B4%8B%E8%91%B1%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">Koa 的洋葱模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#co-%E5%BA%93%E4%B8%8D%E5%86%8D%E7%A5%9E%E7%A7%98"><span class="toc-number">4.3.</span> <span class="toc-text">co 库不再神秘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/algorithm/" title="FE Algorithm - 阶乘"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-1ef0181f71fe1bd731f172ff3b0fc2d3_1200x500.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611282995&amp;t=42ae5101c61f264a349c808013a9c512" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶38 | 揭秘前端设计模式（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）">核心进阶38 | 揭秘前端设计模式（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）">核心进阶47 | 缓存谁都懂，一问都哑巴（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶49 | HTTP 的深思：我从何而来，去向何处"/></a><div class="content"><a class="title" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处">核心进阶49 | HTTP 的深思：我从何而来，去向何处</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶51 | 大话社区和一名技术者的自我修养"/></a><div class="content"><a class="title" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养">核心进阶51 | 大话社区和一名技术者的自我修养</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>