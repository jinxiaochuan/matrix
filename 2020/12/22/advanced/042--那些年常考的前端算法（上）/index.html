<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶42 | 那些年常考的前端算法（上） | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。 主要内容如下：  我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。 前端和算法前端和算法有什么关系呢？我想先纠正两个常见的错误认知。 关于">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶42 | 那些年常考的前端算法（上）">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/042--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。 主要内容如下：  我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。 前端和算法前端和算法有什么关系呢？我想先纠正两个常见的错误认知。 关于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:modified_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/042--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-22 20:51:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/matrix/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶42 | 那些年常考的前端算法（上）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-22T12:51:17.444Z" title="更新于 2020-12-22 20:51:17">2020-12-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>在上一讲中，我们全面梳理了重要的数据结构，并用 JavaScript<br>对各种数据结构进行了实现和方法模拟。数据结构常与算法一起出现，两者相互依存密不可分。这一讲，我们来研究一下“那些年常考的前端算法”。</p>
<p>主要内容如下：</p>
<p><img src="https://images.gitbook.cn/a80ed7e0-d827-11e9-a98d-91914e1a8fb9" alt="enter image description
here"></p>
<p>我们将通过三讲的内容来剖析算法问题。本讲先“轻松”一下，主要介绍前端和算法的关系，以及算法中的一些基本概念。</p>
<h3 id="前端和算法"><a href="#前端和算法" class="headerlink" title="前端和算法"></a>前端和算法</h3><p>前端和算法有什么关系呢？我想先纠正两个常见的错误认知。</p>
<h4 id="关于算法的误解"><a href="#关于算法的误解" class="headerlink" title="关于算法的误解"></a>关于算法的误解</h4><ul>
<li>前端没有算法？</li>
</ul>
<p>“前端没有算法”这种说法往往出自算法岗甚至后端读者，这种认知是错误的。前端不仅有算法，而且算法在前端开发中占据的地位也越来越重要。我们常提到的<br>Virtual dom diff、webpack 实现、React fiber、React<br>hooks、响应式编程、浏览器引擎工作方式等都有算法的影子。在业务代码中，哪怕写一个抽奖游戏，写一个混淆函数都离不开算法。</p>
<ul>
<li>算法重要不重要？</li>
</ul>
<p>有读者认为，前端中算法只是提供了一些偏底层的能力和实现支持，我在业务开发中真正使用到算法的场景也很有限。事实上，不仅单纯的前端业务，哪怕对于后端业务来说，真正让你“徒手”实现一段算法的场景也不算多。但是据此得出算法不重要的说法还是太片面了。为什么高阶面试中总会问到算法呢？因为算法很好地反应了候选者编程思维和计算机素养；另一方面，如果我们想进阶，算法也是必须要攻克的一道难关。</p>
<h4 id="前端和算法简单举例"><a href="#前端和算法简单举例" class="headerlink" title="前端和算法简单举例"></a>前端和算法简单举例</h4><p>我就先举一个例子作为引子，一起先热热身，看看算法应用在前端开发中的一个小细节。</p>
<p>想必不少读者写过“抽奖”代码，或者“老虎机”转盘。其中可能会涉及到一个问题，就是：</p>
<blockquote>
<p>“如何将一个 JavaScript 数组打乱顺序？”</p>
</blockquote>
<p>事实上乱序一个数组不仅仅是前端课题，那么这个问题在前端的背景下，有哪些特点呢？可能有读者首先想到使用数组的 sort API，再结合 Math.random<br>实现：</p>
<pre><code>[12,4,16,3].sort(function() &#123;
    return .5 - Math.random();
&#125;)</code></pre>
<p>这样的思路非常自然，但也许你不知道：这不是真正意义上的完全乱序。</p>
<p>为此我们进行验证，对数组</p>
<pre><code>let letters = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;]</code></pre>
<p>使用 array.sort 方法进行了 10000 次乱序处理，并对乱序之后得到的新数组中，每一个字母出现的位置进行统计，并可视化输出：</p>
<pre><code>&lt;body&gt;
        &lt;table id=&quot;results&quot;&gt;
            &lt;tr&gt;
                &lt;th style=&quot;background-color:#ccccff&quot;&gt;Results&lt;/th&gt;
                &lt;th&gt;slot 0&lt;/th&gt;
                &lt;th&gt;slot 1&lt;/th&gt;
                &lt;th&gt;slot 2&lt;/th&gt;
                &lt;th&gt;slot 3&lt;/th&gt;
                &lt;th&gt;slot 4&lt;/th&gt;
                &lt;th&gt;slot 5&lt;/th&gt;
                &lt;th&gt;slot 6&lt;/th&gt;
                &lt;th&gt;slot 7&lt;/th&gt;
                &lt;th&gt;slot 8&lt;/th&gt;
                &lt;th&gt;slot 9&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;A&#39;s&lt;/th&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;B&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;C&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;D&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;E&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;F&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;G&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;H&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;bias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;I&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;th&gt;J&#39;s&lt;/th&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td class=&quot;strongbias&quot;&gt;0&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; value=&quot;recalculate&quot; onclick=&quot;recalc()&quot;&gt;
        &lt;/div&gt;
    &lt;/body&gt;
    &lt;script&gt;
        const recalc = () =&gt; &#123;
            const countings = [
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;,
                &#123;A:0,B:0,C:0,D:0,E:0,F:0,G:0,H:0,I:0,J:0&#125;
            ]
            let letters=[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;];
            for (let i = 0; i &lt; 10000; i++) &#123;
                var r = [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;,&#39;F&#39;,&#39;G&#39;,&#39;H&#39;,&#39;I&#39;,&#39;J&#39;].sort(function() &#123;
                    return .5 - Math.random()
                &#125;)
                for(var j = 0; j &lt;= 9; j++) &#123;
                    countings[j][r[j]]++
                &#125;
            &#125;
            for(var i = 0; i &lt;= 9;i++) &#123;
                for(var j = 0;j &lt;= 9;j++) &#123;
                    document.getElementById(&#39;results&#39;).rows[i + 1].cells[j + 1].firstChild.data = countings[i][letters[j]]
                &#125;
            &#125;
        &#125;
        recalc()
    &lt;/script&gt;</code></pre>
<p>得到结果：</p>
<p><img src="https://images.gitbook.cn/75e69d10-d828-11e9-8fae-816b29059b0c" alt="1"></p>
<p>不管点击按钮几次，你都会发现整体乱序之后的结果绝对不是“完全随机”。</p>
<p>比如，A 元素大概率出现在数组的头部，J 元素大概率出现在数组的尾部，所有元素大概率停留在自己初始位置。</p>
<p>这是为什么呢？</p>
<p>究其原因，在 Chrome v8 引擎源码中，可以清晰看到：</p>
<blockquote>
<p>v8 在处理 sort 方法时，使用了插入排序和快排两种方案。当目标数组长度小于 10（不同版本有差别）时，使用插入排序；反之，使用快排。</p>
</blockquote>
<p>其实不管用什么排序方法，大多数排序算法的时间复杂度介于 O(n) 到 O(n2) 之间，元素之间的比较次数通常情况下要远小于<br>n(n-1)/2，也就意味着有一些元素之间根本就没机会相比较（也就没有了随机交换的可能），这些 sort 随机排序的算法自然也不能真正随机。</p>
<p>通俗地说，其实我们使用 array.sort 进行乱序，理想的方案或者说纯乱序的方案是：数组中每两个元素都要进行比较，这个比较有 50%<br>的交换位置概率。如此一来，总共比较次数一定为 n(n-1)。</p>
<p>而在 sort 排序算法中，大多数情况都不会满足这样的条件，因此当然不是完全随机的结果了。</p>
<p>那为了满足乱序一个数组的需求，我们应该怎么做呢？</p>
<p>Fisher–Yates shuffle<br>洗牌算法——会是一个更好的选择。这里，我们简单借助图形来理解，非常简单直观。接下来就会明白为什么这是理论上的完全乱序（图片来源于网络）。</p>
<p>首先我们有一个已经排好序的数组：</p>
<p><img src="https://images.gitbook.cn/d8ed90d0-d828-11e9-8797-4924c0d7c082" alt="2"></p>
<p><strong>Step1</strong> ：</p>
<p>这一步需要做的就是，从数组末尾开始，选取最后一个元素。</p>
<p><img src="https://images.gitbook.cn/fd022b20-d828-11e9-9143-0bdf45914741" alt="3"></p>
<p>在数组一共 9 个位置中，随机产生一个位置，该位置元素与最后一个元素进行交换。</p>
<p><img src="https://images.gitbook.cn/68a6a040-d829-11e9-a98d-91914e1a8fb9" alt="4"></p>
<p><img src="https://images.gitbook.cn/80791b30-d829-11e9-a98d-91914e1a8fb9" alt="5"></p>
<p><img src="https://images.gitbook.cn/9dc03930-d829-11e9-9143-0bdf45914741" alt="6"></p>
<p><strong>Step2：</strong></p>
<p>在上一步中，我们已经把数组末尾元素进行随机置换。</p>
<p>接下来，对数组倒数第二个元素动手。在除去已经排好的最后一个元素位置以外的 8 个位置中，随机产生一个位置，该位置元素与倒数第二个元素进行交换。</p>
<p><img src="https://images.gitbook.cn/f0037d10-d829-11e9-8797-4924c0d7c082" alt="7"></p>
<p><img src="https://images.gitbook.cn/0aa48150-d82a-11e9-9143-0bdf45914741" alt="8"></p>
<p><img src="https://images.gitbook.cn/252b1fc0-d82a-11e9-8797-4924c0d7c082" alt="9"></p>
<p><strong>Step3：</strong></p>
<p>理解了前两步，接下来就是依次进行，如此简单。</p>
<p><img src="https://images.gitbook.cn/7cd8cd80-d82a-11e9-8fae-816b29059b0c" alt="10"></p>
<p>明白了原理，代码实现也很简单：</p>
<pre><code>Array.prototype.shuffle = function() &#123;
    var array = this;
    var m = array.length,
        t, i;
    while (m) &#123;
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    &#125;
    return array;
&#125;</code></pre>
<h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><p>在具体讲解各种算法前，我们有必要先掌握基本概念。搞定算法，需要读者优先了解数据结构以及各种结构的相关方法，这些内容上一讲中已经进行了梳理。另外一个重要概念就是算法复杂度了，它是评估一个算法优秀程度的重要考证。我们常说的时间复杂度和空间复杂度该如何理解呢？</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>我们先看一下时间复杂度的概念：</p>
<blockquote>
<p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。</p>
</blockquote>
<p>但是时间复杂度的计算既可以“有理可依”，又可以靠“主观感觉”。通常我们认为：</p>
<ul>
<li>没有循环语句，时间复杂度记作 O(1)，我们称为常数阶；</li>
<li>只有一重循环，那么算法的基本操作的执行频度与问题规模 n 呈线性增大关系，记作 O（n），也叫线性阶。</li>
</ul>
<p>那么如何让时间复杂度的计算“有理可依”呢？来看几个原则：</p>
<ul>
<li>只看循环次数最多的代码</li>
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
<li>乘法法则：嵌套代码的复杂度等于嵌套内外复杂度的乘积</li>
</ul>
<p>我们来逐一分析：</p>
<pre><code>const cal = n =&gt; &#123; 
   let sum = 0
   let i = 1
   for (; i &lt;= n; ++i) &#123;
     sum = sum + i
   &#125;
   return sum
 &#125;</code></pre>
<p>执行次数最多的是 for 循环及里面的代码，执行了 n 次，应该“只看循环次数最多的代码”原则，因此时间复杂度为 O(n)。</p>
<pre><code>const cal = n =&gt; &#123;
   let sum1 = 0
   let p = 1

   for (; p &lt; 100; ++p) &#123;
     sum1= sum1 + p
   &#125;

   let sum2 = 0
   let q = 1
   for (; q &lt; n; ++q) &#123;
     sum2 = sum2 + q
   &#125;

   let sum3 = 0
   let i = 1
   let j = 1
   for (; i &lt;= n; ++i) &#123;
     j = 1
     for (; j &lt;= n; ++j) &#123;
       sum3 = sum3 +  i * j
     &#125;
   &#125;

   return sum1 + sum2 + sum3
 &#125;</code></pre>
<p>上述代码分别对 sum1、sum2、sum3 求和：</p>
<ul>
<li>对于 sum1 求和，循环 100 次，常数执行时间，时间复杂度为 O(1)；</li>
<li>对于 sum2 求和，循环规模为 n，时间复杂度为 O(n)；</li>
<li>对于 sum3 求和，两层循环，时间复杂度为 O(n²)。</li>
</ul>
<p>因此 O(1) + O(n) + O(n²)，取三段代码的最大量级，上面例子最终的时间复杂度为 O(n²)。</p>
<p>对于代码：</p>
<pre><code>const cal = n =&gt; &#123;
   let ret = 0
   let i = 1
   for (; i &lt; n; ++i) &#123;
     ret = ret + f(i); // 注意  f(i)
   &#125; 
 &#125; 

const f = n =&gt; &#123;
  let sum = 0
  let i = 1
  for (; i &lt; n; ++i) &#123;
    sum = sum + i
  &#125; 
  return sum
 &#125;</code></pre>
<p>方法 cal 循环里面调用 f 方法，而 f 方法里面也有循环，这时应用第三个原则——乘法原则，得到时间复杂度 O(n²)。</p>
<p>最后我们再看一个对数阶的概念：</p>
<pre><code>const aFun = n =&gt; &#123;
  let i = 1;
  while (i &lt;= n)  &#123;
     i = i * 2
  &#125;
  return i
&#125;

const cal = n =&gt; &#123; 
   let sum = 0
   for (let i = 1; i &lt;= n; ++i) &#123;
     sum = sum + aFun(n)
   &#125;
   return sum
 &#125;</code></pre>
<p>这里的不同之处是 aFun 每次循环，i = i * 2，那么自然不再是全遍历。想想高中学过的等比数列：</p>
<pre><code>2^0 * 2^1 * 2^2 * 2^k * 2^x = n</code></pre>
<p>因此，我们只要知道 x 值是多少，就知道这行代码执行的次数了，通过 2x = n 求解 x，数学中求解得 x = log2n 。即上面代码的时间复杂度为<br>O(log2n)。</p>
<p>但是不知道读者有没有发现：不管是以 2 为底，还是以 K 为底，我们似乎都把所有对数阶的时间复杂度都记为 O(logn)。这又是为什么呢？</p>
<p>事实上，基本的数学概念告诉我们：对数之间是可以互相转换的，log3n = log32 * log2n，因此 O(log3n) = O(C *<br>log2n)，其中 C=log32 是一个常量。所以全部以 2 为底，并没有什么问题。</p>
<p>总之，需要读者准确理解：由于 <strong>时间复杂度</strong> 描述的是 <strong>算法执行时间与数据规模的增长变化趋势</strong><br>，因而常量、低阶、系数实际上对这种增长趋势不产生决定性影响，所以在做时间复杂度分析时忽略这些项。</p>
<h4 id="最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度"><a href="#最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度" class="headerlink" title="最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度"></a>最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度</h4><p>我们来看一段代码：</p>
<pre><code>const find = (array, x) =&gt; &#123;
    let pos = -1
    let n = array.length

    for (let i = 0; i &lt; n; ++i) &#123;
        if (array[i] === x) &#123;
            pos = i
        &#125;
    &#125;

    return pos
&#125;</code></pre>
<p>上面的代码有一层循环，循环规模和 n 成线性关系。因此时间复杂度为 O(n)，我们改动代码为：</p>
<pre><code>const find = (array, x) =&gt; &#123;
     let pos = -1
     let n = array.length

     for (let i = 0; i &lt; n; ++i) &#123;
            if (array[i] === x) &#123;
                 pos = i 
                 break
            &#125;
      &#125;
      return pos
&#125;</code></pre>
<p>在找到第一个匹配元素后，循环终止，那么时间复杂度就不一定是 O(n) 了，因此就有了最好时间复杂度、最坏时间复杂度的区别。针对上述代码最好时间复杂度就是<br>O(1)、最坏时间复杂度还是 O(n)。</p>
<p>最好时间复杂度、最坏时间复杂度其实都是极端情况，我们可以从统计学角度给出一个平均时间复杂度。在上述代码中，平均时间复杂度的计算方式应该是：</p>
<pre><code>(1/(n+1)) * 1 + (1/(n+1)) * 2 + ... + (1/(n+1)) * n + (1/(n+1)) * n</code></pre>
<p>得到结果为：n(n+3)/2(n+1)</p>
<p>因为变量 x 出现在数组中的位置分别有 0 —— n－1 种情况，对应需要遍历的次数；除此之外，还有变量 x 不出现在数组中，这种情况仍然后遍历完数组。</p>
<p>上述结果简化之后仍然得到 O(n)。</p>
<p>我们再来看一段代码：</p>
<pre><code>let array = new Array(n)
let count = 0
function insert(val) &#123;
    let len = array.length
    if (count === len) &#123;
        let sum = 0
        for (let i = 0; i &lt; len; i++) &#123;
            sum = sum + array[i]
        &#125;
        array[0] = sum
        count = 1
    &#125;
    array[count] = val
    ++count
&#125;</code></pre>
<p>这段代码逻辑很简单：我们实现了一个往数组中插入数据的功能。但是多了些判断：当数组满了之后，即 count === len 时，采用 for<br>循环对数组进行求和，求和完毕之后：先清空数组，然后将求和之后的结果放到数组的第一个位置，最后再将新的数据插入。</p>
<p>这是一段非常典型的代码，我们来看它的时间复杂度：</p>
<ul>
<li>最好时间复杂度</li>
</ul>
<p>数组中有空闲，count !== len，直接执行插入操作，复杂度为 O(1)。</p>
<ul>
<li>最好时间复杂度</li>
</ul>
<p>数组已满，count === len，需要先遍历一遍再求和，复杂度为 O(n)。</p>
<ul>
<li>平均时间复杂度</li>
</ul>
<p>假设数组长度为 n，数组空闲时，复杂度为 O(1)；数组已满，复杂度为 O(n)。采用平均加权方式：</p>
<pre><code>(1/(n+1)) * 1 + (1/(n+1)) * 1 + ... + (1/(n+1)) * n</code></pre>
<p>公式求和仍为 O(1)，主观上想：我们的操作是在进行了 n 个 O(1) 的插入操作后，此时数组满了，执行一次 O(n)<br>的求和和清空操作。这样一来，其实前面的 n 个O (1) 和最后的 1 个 O(n) 其实是可以抵消掉的，这是一种均摊时间复杂度的概念。</p>
<p>这种均摊的概念是有实际应用场景的。例如，C++ 里的 vector 动态数组的自动扩容机制，每次往 vector 里 push 值的时候会判断当前 size<br>是否等于 capacity，一旦元素超过容器限制，则再申请扩大一倍的内存空间，把原来 vector 里的值复制到新的空间里，触发扩容的这次 push<br>操作的时间复杂度是 O(n)，但均摊到前面 n 个元素后，可以认为时间复杂度是 O(1) 常数。</p>
<p>最后总结一下，常见时间复杂度：</p>
<ul>
<li>O(1)：基本运算 +、-、*、/、%、寻址</li>
<li>O(logn)：二分查找，跟分治（Divide &amp; Conquer）相关的基本上都是 logn</li>
<li>O(n)：线性查找</li>
<li>O(nlogn)：归并排序，快速排序的期望复杂度，基于比较排序的算法下界</li>
<li>O(n²)：冒泡排序，插入排序，朴素最近点对</li>
<li>O(n³)：Floyd 最短路，普通矩阵乘法</li>
<li>O(2ⁿ)：枚举全部子集</li>
<li>O(n!)：枚举全排列</li>
</ul>
<p>O(logn) 近似于是常数的时间复杂度，当 n 为 $2^{32}$ 的规模时 logn 也只是 32 而已；<br>对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。例如，O(n²) + O(n) 可直接记做 O(n²)。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度表示算法的存储空间与数据规模之间的增长关系。常见的空间复杂度：O(1)、O(n)、O(n²)，像 O(logn)、O(nlogn)<br>这样的对数阶复杂度平时都用不到。有的题目在空间上要求 in-place（原地），是指使用 O(1) 空间，在输入的空间上进行原地操作，比如字符串反转。但<br>in-place 又不完全等同于常数的空间复杂度，比如数组的快排认为是 in-place 交换，但其递归产生的堆栈的空间是可以不考虑的，因此 in-<br>place 相对 O(1) 空间的要求会更宽松一点。</p>
<p>对于时间复杂度和空间复杂度，开发者应该有所取舍。在设计算法时，可以考虑“牺牲空间复杂度，换取时间复杂度的优化”，反之依然。空间复杂度我们不再过多介绍。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本讲我们介绍了算法的基本概念，重点就是时间复杂度和空间复杂度分析，同时剖出了一个“乱序数组”算法进行热身。算法的大门才刚刚打开，请读者继续保持学习。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/042--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/">https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/042--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/2020/12/22/advanced/041--%E5%8F%A4%E8%80%81%E5%8F%88%E6%96%B0%E6%BD%AE%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶41 | 古老又新潮的函数式</div></div></a></div><div class="next-post pull-right"><a href="/matrix/2020/12/22/advanced/044--%E9%82%A3%E4%BA%9B%E5%B9%B4%E5%B8%B8%E8%80%83%E7%9A%84%E5%89%8D%E7%AB%AF%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶44 | 那些年常考的前端算法（下）</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/matrix/null" onerror="this.onerror=null;this.src='/matrix/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">前端和算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%AF%E8%A7%A3"><span class="toc-number">1.1.</span> <span class="toc-text">关于算法的误解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%92%8C%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E4%B8%BE%E4%BE%8B"><span class="toc-number">1.2.</span> <span class="toc-text">前端和算法简单举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">算法的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%8C%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.2.</span> <span class="toc-text">最好、最坏时间复杂度，平均时间复杂度，均摊时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.3.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="01 | 项目基石：前端脚手架工具探秘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘">01 | 项目基石：前端脚手架工具探秘</a><time datetime="2020-12-22T12:51:17.448Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）">核心进阶25 | 深入浅出模块化（含 tree shaking）（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶29 | 前端工程化背后的项目组织设计（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）">核心进阶29 | 前端工程化背后的项目组织设计（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶30 | 代码规范工具及背后技术设计（上）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）">核心进阶30 | 代码规范工具及背后技术设计（上）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>