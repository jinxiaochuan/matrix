<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶05 | 我们不背诵 API，只实现 API | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="有不少刚入行的同学跟我说：“JavaScript 很多 API 记不清楚怎么办？数组的这方法、那方法总是傻傻分不清楚，该如何是好？操作 DOM的方式今天记、明天忘，真让人奔溃！”甚至有的开发者在讨论面试时，总向我抱怨：“面试官总爱纠结 API 的使用，甚至 jQuery某些方法的参数顺序都需要让我说清楚！” 我认为，对于反复使用的方法，所有人都要做到“机械记忆”，能够反手写出。一些貌似永远记不清的">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶05 | 我们不背诵 API，只实现 API">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/advanced/005--%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%8C%E8%AF%B5%20API%EF%BC%8C%E5%8F%AA%E5%AE%9E%E7%8E%B0%20API/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="有不少刚入行的同学跟我说：“JavaScript 很多 API 记不清楚怎么办？数组的这方法、那方法总是傻傻分不清楚，该如何是好？操作 DOM的方式今天记、明天忘，真让人奔溃！”甚至有的开发者在讨论面试时，总向我抱怨：“面试官总爱纠结 API 的使用，甚至 jQuery某些方法的参数顺序都需要让我说清楚！” 我认为，对于反复使用的方法，所有人都要做到“机械记忆”，能够反手写出。一些貌似永远记不清的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360">
<meta property="article:published_time" content="2020-12-23T03:47:50.488Z">
<meta property="article:modified_time" content="2020-12-23T03:47:50.488Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/advanced/005--%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%8C%E8%AF%B5%20API%EF%BC%8C%E5%8F%AA%E5%AE%9E%E7%8E%B0%20API/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-23 11:47:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="onerror=null;src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶05 | 我们不背诵 API，只实现 API</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-23T03:47:50.488Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-23T03:47:50.488Z" title="更新于 2020-12-23 11:47:50">2020-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>有不少刚入行的同学跟我说：“JavaScript 很多 API 记不清楚怎么办？数组的这方法、那方法总是傻傻分不清楚，该如何是好？操作 DOM<br>的方式今天记、明天忘，真让人奔溃！”甚至有的开发者在讨论面试时，总向我抱怨：“面试官总爱纠结 API 的使用，甚至 jQuery<br>某些方法的参数顺序都需要让我说清楚！”</p>
<p>我认为，对于反复使用的方法，所有人都要做到“机械记忆”，能够反手写出。一些貌似永远记不清的 API 只是因为用得不够多而已。</p>
<p>在做面试官时，我从来不强求开发者准确无误地“背诵” API。相反，我喜欢从另外一个角度来考察面试者：“<br><strong>既然记不清使用方法，那么我告诉你它的使用方法，你来实现一个吧！</strong> ”实现一个 API，除了可以考察面试者对这个 API<br>的理解，更能体现开发者的编程思维和代码能力。对于积极上进的前端工程师，模仿并实现一些经典方法，应该是“家常便饭”，这是比较基本的要求。</p>
<p><strong>本小节，我根据了解的面试题目和作为面试官的经历，挑了几个典型的 API，通过对其不同程度，不同方式的实现，来覆盖 JavaScript<br>中的部分知识点和编程要领</strong> 。通过学习本节内容，期待你不仅能领会代码奥义，更应该学习举一反三的方法。</p>
<p>API 主题的相关知识点如下：</p>
<p><img src="https://images.gitbook.cn/331cceb0-4ed4-11e9-8044-3de24c2bc492"></p>
<h3 id="jQuery-offset-实现"><a href="#jQuery-offset-实现" class="headerlink" title="jQuery offset 实现"></a>jQuery offset 实现</h3><blockquote>
<p>这个话题演变自今日头条某部门面试题。当时面试官提问：“如何获取文档中任意一个元素距离文档 <code>document</code> 顶部的距离？”</p>
</blockquote>
<p>熟悉 jQuery 的读者应该对 <code>offset</code><br>方法并不陌生，它返回或设置匹配元素相对于文档的偏移（位置）。这个方法返回的对象包含两个整型属性：<code>top</code> 和 <code>left</code>，以像素计。如果可以使用<br>jQuery， 我们可以直接调取该 API 获得结果。但是， <strong>如果用原生 JavaScript 实现，也就是说手动实现 jQuery<code>offset</code><br>方法，该如何着手呢？</strong></p>
<p>主要有两种思路：</p>
<ul>
<li>通过递归实现</li>
<li>通过 <code>getBoundingClientRect</code> API 实现</li>
</ul>
<h4 id="递归实现方案"><a href="#递归实现方案" class="headerlink" title="递归实现方案"></a>递归实现方案</h4><p>我们通过遍历目标元素、目标元素的父节点、父节点的父节点……依次溯源，并累加这些遍历过的节点相对于其最近祖先节点（且 <code>position</code> 属性非<br><code>static</code>）的偏移量，向上直到 <code>document</code>，累加即可得到结果。</p>
<p>其中，我们需要使用 JavaScript 的 <code>offsetTop</code> 来访问一个 DOM 节点上边框相对离其本身最近、且 <code>position</code> 值为非<br><code>static</code> 的祖先元素的垂直偏移量。具体实现为：</p>
<pre><code>const offset = ele =&gt; &#123;
    let result = &#123;
        top: 0,
        left: 0
    &#125;

const getOffset = (node, init) =&gt; &#123;
        if (node.nodeType !== 1) &#123;
            return
        &#125;

        position = window.getComputedStyle(node)[&#39;position&#39;]

        if (typeof(init) === &#39;undefined&#39; &amp;&amp; position === &#39;static&#39;) &#123;
            getOffset(node.parentNode)
            return
        &#125;

        result.top = node.offsetTop + result.top - node.scrollTop
        result.left = node.offsetLeft + result.left - node.scrollLeft

        if (position === &#39;fixed&#39;) &#123;
            return
        &#125;

        getOffset(node.parentNode)
    &#125;

    // 当前 DOM 节点的 display === &#39;none&#39; 时, 直接返回 &#123;top: 0, left: 0&#125;
    if (window.getComputedStyle(ele)[&#39;display&#39;] === &#39;none&#39;) &#123;
        return result
    &#125;

    let position

    getOffset(ele, true)

    return result

&#125;</code></pre>
<p>上述代码并不难理解，使用递归实现。如果节点 <code>node.nodeType</code> 类型不是 <code>Element(1)</code>，则跳出；如果相关节点的 <code>position</code><br>属性为 <code>static</code>，则不计入计算，进入下一个节点（其父节点）的递归。如果相关属性的 <code>display</code> 属性为 <code>none</code>，则应该直接返回 0<br>作为结果。</p>
<p>这个实现很好地考察了开发者对于递归的初级应用、以及对 JavaScript 方法的掌握程度。</p>
<p>接下来，我们换一种思路，用一个相对较新的 API： <code>getBoundingClientRect</code> 来实现 jQuery <code>offset</code> 方法。</p>
<h4 id="getBoundingClientRect-方法"><a href="#getBoundingClientRect-方法" class="headerlink" title="getBoundingClientRect 方法"></a>getBoundingClientRect 方法</h4><p><code>getBoundingClientRect</code><br>方法用来描述一个元素的具体位置，该位置的下面四个属性都是相对于视口左上角的位置而言的。对某一节点执行该方法，它的返回值是一个<br>[DOMRect](<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-">https://developer.mozilla.org/zh-</a><br>CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect)<br>类型的对象。这个对象表示一个矩形盒子，它含有：<code>left</code>、<code>top</code>、<code>right</code> 和 <code>bottom</code> 等只读属性。</p>
<p><img src="https://images.gitbook.cn/db68ca10-4eac-11e9-b1fa-0757868d211c"></p>
<p>请参考实现代码：</p>
<pre><code>const offset = ele =&gt; &#123;
    let result = &#123;
        top: 0,
        left: 0
    &#125;
    // 当前为 IE11 以下，直接返回 &#123;top: 0, left: 0&#125;
    if (!ele.getClientRects().length) &#123;
        return result
    &#125;

    // 当前 DOM 节点的 display === &#39;none&#39; 时，直接返回 &#123;top: 0, left: 0&#125;
    if (window.getComputedStyle(ele)[&#39;display&#39;] === &#39;none&#39;) &#123;
        return result
    &#125;

    result = ele.getBoundingClientRect()
    var docElement = ele.ownerDocument.documentElement

    return &#123;
        top: result.top + window.pageYOffset - docElement.clientTop,
        left: result.left + window.pageXOffset - docElement.clientLeft
    &#125;
&#125;</code></pre>
<p><strong>需要注意的细节有：</strong></p>
<ul>
<li><p><code>node.ownerDocument.documentElement</code> 的用法可能大家比较陌生，<code>ownerDocument</code> 是 DOM 节点的一个属性，它返回当前节点的顶层的 <code>document</code> 对象。<code>ownerDocument</code> 是文档，<code>documentElement</code> 是根节点。事实上，<code>ownerDocument</code> 下含 2 个节点：</p>
</li>
<li><p><code>&lt;!DocType&gt;</code></p>
</li>
<li><p><code>documentElement</code></p>
</li>
</ul>
<p><code>docElement.clientTop</code>，<code>clientTop</code> 是一个元素顶部边框的宽度，不包括顶部外边距或内边距。</p>
<ul>
<li>除此之外，该方法实现就是简单的几何运算，边界 case 和兼容性处理，也并不难理解。</li>
</ul>
<p>从这道题目看出，相比考察“死记硬背”<br>API，这样的实现更有意义。站在面试官的角度，我往往会给面试者（开发者）提供相关的方法提示，以引导其给出最后的方案实现。</p>
<h3 id="数组-reduce-方法的相关实现"><a href="#数组-reduce-方法的相关实现" class="headerlink" title="数组 reduce 方法的相关实现"></a>数组 reduce 方法的相关实现</h3><p>数组方法非常重要： <strong>因为数组就是数据，数据就是状态，状态反应着视图</strong> 。对数组的操作我们不能陌生，其中 <code>reduce</code><br>方法更要做到驾轻就熟。我认为这个方法很好地体现了“函数式”理念，也是当前非常热门的考察点之一。</p>
<p>我们知道 <code>reduce</code> 方法是 ES5 引入的，reduce 英文解释翻译过来为“减少，缩小，使还原，使变弱”，MDN 对该方法直述为：</p>
<blockquote>
<p>The reduce method applies a function against an accumulator and each value<br>of the array (from left-to-right) to reduce it to a single value.</p>
</blockquote>
<p>它的使用语法：</p>
<pre><code>arr.reduce(callback[, initialValue])</code></pre>
<p>这里我们简要介绍一下。</p>
<ul>
<li><code>reduce</code> 第一个参数 <code>callback</code> 是核心，它对数组的每一项进行“叠加加工”，其最后一次返回值将作为 <code>reduce</code> 方法的最终返回值。 它包含 4 个参数：</li>
<li><code>previousValue</code> 表示“上一次” <code>callback</code> 函数的返回值</li>
<li><code>currentValue</code> 数组遍历中正在处理的元素</li>
<li><code>currentIndex</code> 可选，表示 <code>currentValue</code> 在数组中对应的索引。如果提供了 <code>initialValue</code>，则起始索引号为 0，否则为 1</li>
<li><code>array</code> 可选，调用 <code>reduce()</code> 的数组</li>
<li><code>initialValue</code> 可选，作为第一次调用 <code>callback</code> 时的第一个参数。如果没有提供 <code>initialValue</code>，那么数组中的第一个元素将作为 <code>callback</code> 的第一个参数。</li>
</ul>
<h4 id="reduce-实现-runPromiseInSequence"><a href="#reduce-实现-runPromiseInSequence" class="headerlink" title="reduce 实现 runPromiseInSequence"></a>reduce 实现 runPromiseInSequence</h4><p>我们看它的 <strong>一个典型应用</strong> ，按顺序运行 Promise：</p>
<pre><code>const runPromiseInSequence = (array, value) =&gt; array.reduce(
    (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),
    Promise.resolve(value)
)</code></pre>
<p><code>runPromiseInSequence</code> 方法将会被一个每一项都返回一个 Promise 的数组调用，并且依次执行数组中的每一个<br>Promise，请读者仔细体会。如果觉得晦涩，可以参考示例：</p>
<pre><code>const f1 = () =&gt; new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        console.log(&#39;p1 running&#39;)
        resolve(1)
    &#125;, 1000)
&#125;)

const f2 = () =&gt; new Promise((resolve, reject) =&gt; &#123;
    setTimeout(() =&gt; &#123;
        console.log(&#39;p2 running&#39;)
        resolve(2)
    &#125;, 1000)
&#125;)

const array = [f1, f2]

const runPromiseInSequence = (array, value) =&gt; array.reduce(
    (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction),
    Promise.resolve(value)
)

runPromiseInSequence(array, &#39;init&#39;)</code></pre>
<p>执行结果如下图：</p>
<p><img src="https://images.gitbook.cn/d3e0d510-74c4-11e9-9e0d-e1101fcb8c7e"></p>
<h4 id="reduce-实现-pipe"><a href="#reduce-实现-pipe" class="headerlink" title="reduce 实现 pipe"></a>reduce 实现 pipe</h4><p><code>reduce</code> 的另外一个 <strong>典型应用</strong> 可以参考函数式方法 <code>pipe</code> 的实现：<code>pipe(f, g, h)</code> 是一个 curry<br>化函数，它返回一个新的函数，这个新的函数将会完成 <code>(...args) =&gt; h(g(f(...args)))</code> 的调用。即 <code>pipe</code><br>方法返回的函数会接收一个参数，这个参数传递给 <code>pipe</code> 方法第一个参数，以供其调用。</p>
<pre><code>const pipe = (...functions) =&gt; input =&gt; functions.reduce(
    (acc, fn) =&gt; fn(acc),
    input
)</code></pre>
<p>仔细体会 <code>runPromiseInSequence</code> 和 <code>pipe</code> 这两个方法，它们都是 <code>reduce</code> 应用的典型场景。</p>
<h4 id="实现一个-reduce"><a href="#实现一个-reduce" class="headerlink" title="实现一个 reduce"></a>实现一个 reduce</h4><p>那么我们该如何实现一个 <code>reduce</code> 呢？参考来自 MDN 的 polyfill：</p>
<pre><code>if (!Array.prototype.reduce) &#123;
  Object.defineProperty(Array.prototype, &#39;reduce&#39;, &#123;
    value: function(callback /*, initialValue*/) &#123;
      if (this === null) &#123;
        throw new TypeError( &#39;Array.prototype.reduce &#39; + 
          &#39;called on null or undefined&#39; )
      &#125;
      if (typeof callback !== &#39;function&#39;) &#123;
        throw new TypeError( callback +
          &#39; is not a function&#39;)
      &#125;

      var o = Object(this)

      var len = o.length &gt;&gt;&gt; 0

      var k = 0
      var value

      if (arguments.length &gt;= 2) &#123;
        value = arguments[1]
      &#125; else &#123;
        while (k &lt; len &amp;&amp; !(k in o)) &#123;
          k++
        &#125;

        if (k &gt;= len) &#123;
          throw new TypeError( &#39;Reduce of empty array &#39; +
            &#39;with no initial value&#39; )
        &#125;
        value = o[k++]
      &#125;

      while (k &lt; len) &#123;
        if (k in o) &#123;
          value = callback(value, o[k], k, o)
        &#125;

        k++
      &#125;

      return value
    &#125;
  &#125;)
&#125;</code></pre>
<p>上述代码中使用了 <code>value</code> 作为初始值，并通过 <code>while</code> 循环，依次累加计算出 <code>value</code> 结果并输出。但是相比 MDN<br>上述实现，我个人更喜欢的实现方案是：</p>
<pre><code>Array.prototype.reduce = Array.prototype.reduce || function(func, initialValue) &#123;
    var arr = this
    var base = typeof initialValue === &#39;undefined&#39; ? arr[0] : initialValue
    var startPoint = typeof initialValue === &#39;undefined&#39; ? 1 : 0
    arr.slice(startPoint)
        .forEach(function(val, index) &#123;
            base = func(base, val, index + startPoint, arr)
        &#125;)
    return base
&#125;</code></pre>
<p>核心原理就是使用 <code>forEach</code> 来代替 <code>while</code> 实现结果的累加，它们本质上是相同的。</p>
<p>我也同样看了下 ES5-shim 里的 pollyfill，跟上述思路完全一致。唯一的区别在于：我用了 <code>forEach</code> 迭代而 ES5-shim<br>使用的是简单的 <code>for</code> 循环。实际上，如果“杠精”一些，我们会指出数组的 <code>forEach</code> 方法也是 ES5 新增的。因此，用 ES5 的一个<br>API（<code>forEach</code>），去实现另外一个 ES5 的 API（<code>reduce</code>），这并没什么实际意义——这里的 pollyfill 就是在不兼容 ES5<br>的情况下，模拟的降级方案。此处不多做追究，因为根本目的还是希望读者对 <code>reduce</code> 有一个全面透彻的了解。</p>
<h4 id="通过-Koa-only-模块源码认识-reduce"><a href="#通过-Koa-only-模块源码认识-reduce" class="headerlink" title="通过 Koa only 模块源码认识 reduce"></a>通过 Koa only 模块源码认识 reduce</h4><p>通过了解并实现 <code>reduce</code> 方法，我们对它已经有了比较深入的认识。最后，再来看一个 <code>reduce</code> 使用示例——通过 Koa 源码的<br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/only">only</a> 模块，加深印象：</p>
<pre><code>var o = &#123;
    a: &#39;a&#39;,
    b: &#39;b&#39;,
    c: &#39;c&#39;
&#125;
only(o, [&#39;a&#39;,&#39;b&#39;])   // &#123;a: &#39;a&#39;,  b: &#39;b&#39;&#125;</code></pre>
<p>该方法返回一个经过指定筛选属性的新对象。 ​<br>only 模块实现：</p>
<pre><code>var only = function(obj, keys)&#123;
    obj = obj || &#123;&#125;
    if (&#39;string&#39; == typeof keys) keys = keys.split(/ +/)
    return keys.reduce(function(ret, key) &#123;
        if (null == obj[key]) return ret
        ret[key] = obj[key]
        return ret
    &#125;, &#123;&#125;)
&#125;</code></pre>
<p>小小的 <code>reduce</code> 及其衍生场景有很多值得我们玩味、探究的地方。举一反三，活学活用是技术进阶的关键。</p>
<h3 id="compose-实现的几种方案"><a href="#compose-实现的几种方案" class="headerlink" title="compose 实现的几种方案"></a>compose 实现的几种方案</h3><p>函数式理念——这一古老的概念如今在前端领域“遍地开花”。函数式很多思想都值得借鉴，其中一个细节：compose<br>因为其巧妙的设计而被广泛运用。对于它的实现，从面向过程式到函数式实现，风格迥异，值得我们探究。在面试当中，也经常有面试官要求实现 <code>compose</code><br>方法，我们先看什么是 <code>compose</code>。</p>
<p><code>compose</code> 其实和前面提到的 <code>pipe</code> 一样，就是执行一连串不定长度的任务（方法），比如：</p>
<pre><code>let funcs = [fn1, fn2, fn3, fn4]
let composeFunc = compose(...funcs)</code></pre>
<p>执行：</p>
<pre><code>composeFunc(args)</code></pre>
<p>就相当于：</p>
<pre><code>fn1(fn2(fn3(fn4(args))))</code></pre>
<p>总结一下 <code>compose</code> 方法的关键点：</p>
<ul>
<li><code>compose</code> 的参数是函数数组，返回的也是一个函数</li>
<li><code>compose</code> 的参数是任意长度的，所有的参数都是函数，执行方向是自右向左的，因此初始函数一定放到参数的最右面</li>
<li><code>compose</code> 执行后返回的函数可以接收参数，这个参数将作为初始函数的参数，所以初始函数的参数是多元的，初始函数的返回结果将作为下一个函数的参数，以此类推。因此除了初始函数之外，其他函数的接收值是一元的</li>
</ul>
<p>我们发现，实际上，<code>compose</code> 和 <code>pipe</code> 的差别只在于调用顺序的不同：</p>
<pre><code>// compose
fn1(fn2(fn3(fn4(args))))

// pipe
fn4(fn3(fn2(fn1(args))))</code></pre>
<p>即然跟我们先前实现的 <code>pipe</code> 方法如出一辙，那么还有什么好深入分析的呢？请继续阅读，看看还能玩出什么花儿来。</p>
<p><code>compose</code> 最简单的实现是面向过程的：</p>
<pre><code>const compose = function(...args) &#123;
    let length = args.length
    let count = length - 1
    let result
    return function f1 (...arg1) &#123;
        result = args[count].apply(this, arg1)
        if (count &lt;= 0) &#123;
            count = length - 1
            return result
        &#125;
        count--
        return f1.call(null, result)
    &#125;
&#125;</code></pre>
<p>这里的关键是用到了 <strong>闭包</strong> ，使用闭包变量储存结果 <code>result</code><br>和函数数组长度以及遍历索引，并利用递归思想，进行结果的累加计算。整体实现符合正常的面向过程思维，不难理解。</p>
<p>聪明的读者可能也会意识到，利用上文所讲的 <code>reduce</code> 方法，应该能更 <strong>函数式</strong> 地解决问题：</p>
<pre><code>const reduceFunc = (f, g) =&gt; (...arg) =&gt; g.call(this, f.apply(this, arg))
const compose = (...args) =&gt; args.reverse().reduce(reduceFunc, args.shift())</code></pre>
<p>通过前面的学习，结合 <code>call</code>、<code>apply</code> 方法，这样的实现并不难理解。</p>
<p><strong>我们继续开拓思路，“既然涉及串联和流程控制”，那么还可以使用 Promise 实现：</strong></p>
<pre><code>const compose = (...args) =&gt; &#123;
    let init = args.pop()
    return (...arg) =&gt; 
    args.reverse().reduce((sequence, func) =&gt; 
      sequence.then(result =&gt; func.call(null, result))
    , Promise.resolve(init.apply(null, arg)))
&#125;</code></pre>
<p>这种实现利用了 Promise 特性：首先通过 <code>Promise.resolve(init.apply(null, arg))</code> 启动逻辑，启动一个<br><code>resolve</code> 值为最后一个函数接收参数后的返回值，依次执行函数。因为 <code>promise.then()</code> 仍然返回一个 Promise 类型值，所以<br><code>reduce</code> 完全可以按照 Promise 实例执行下去。</p>
<p>既然能够使用 Promise 实现，那么 <strong>generator</strong><br>当然应该也可以实现。这里给大家留一个思考题，感兴趣的读者可以尝试，欢迎在评论区或读者群讨论。</p>
<p>最后，我们再看下社区上著名的 lodash 和 Redux 的实现。</p>
<p><strong>lodash 版本</strong></p>
<pre><code>// lodash 版本
var compose = function(funcs) &#123;
    var length = funcs.length
    var index = length
    while (index--) &#123;
        if (typeof funcs[index] !== &#39;function&#39;) &#123;
            throw new TypeError(&#39;Expected a function&#39;);
        &#125;
    &#125;
    return function(...args) &#123;
        var index = 0
        var result = length ? funcs.reverse()[index].apply(this, args) : args[0]
        while (++index &lt; length) &#123;
            result = funcs[index].call(this, result)
        &#125;
        return result
    &#125;
&#125;</code></pre>
<p>lodash 版本更像我们的第一种实现方式，理解起来也更容易。</p>
<p><strong>Redux 版本</strong></p>
<pre><code>// Redux 版本
function compose(...funcs) &#123;
    if (funcs.length === 0) &#123;
        return arg =&gt; arg
    &#125;

    if (funcs.length === 1) &#123;
        return funcs[0]
    &#125;

    return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
&#125;</code></pre>
<p>总之，还是充分利用了数组的 <code>reduce</code> 方法。</p>
<p>函数式概念确实有些抽象，需要开发者仔细琢磨，并动手调试。一旦顿悟，必然会感受到其中的优雅和简洁。</p>
<h3 id="apply、bind-进阶实现"><a href="#apply、bind-进阶实现" class="headerlink" title="apply、bind 进阶实现"></a>apply、bind 进阶实现</h3><p>面试中关于 <code>this</code> 绑定的相关话题如今已经“泛滥”，同时对 <code>bind</code><br>方法的实现，社区上也有相关讨论。但是很多内容尚不系统，且存在一些瑕疵。这里简单摘录我 2017 年年初写的文章<br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/6958f99db769">从一道面试题，到“我可能看了假源码”</a> 来递进讨论。在《一网打尽<br>this》一课中，我们介绍过对 <code>bind</code> 的实现，这里进一步展开讲解。</p>
<p>此处不再赘述 <code>bind</code> 函数的使用，尚不清楚的读者可以自行补充一下基础知识。我们先来看一个初级实现版本：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) &#123;
    var me = this;
    var argsArray = Array.prototype.slice.call(arguments);
    return function () &#123;
        return me.apply(context, argsArray.slice(1))
    &#125;
&#125;</code></pre>
<p>这是一般合格开发者提供的答案，如果面试者能写到这里，给他 60 分。</p>
<p><strong>先简要解读一下：</strong></p>
<p>基本原理是使用 <code>apply</code> 进行模拟 <code>bind</code>。函数体内的 <code>this</code> 就是需要绑定 <code>this</code> 的函数，或者说是原函数。最后使用<br><code>apply</code> 来进行参数（<code>context</code>）绑定，并返回。</p>
<p>与此同时，将第一个参数（<code>context</code>）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“ curry 化”基础。</p>
<p>上述实现方式，我们返回的参数列表里包含：<code>argsArray.slice(1)</code>， <strong>它的问题在于存在预置参数功能丢失的现象。</strong></p>
<p>想象我们返回的绑定函数中，如果想实现预设传参（就像 <code>bind</code> 所实现的那样），就面临尴尬的局面。真正实现“ curry 化”的“完美方式”是：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) &#123;
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function () &#123;
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(context, finalArgs);
    &#125;
&#125;</code></pre>
<p>但继续探究，我们注意 <code>bind</code> 方法中：<code>bind</code> 返回的函数如果作为构造函数，搭配 <code>new</code> 关键字出现的话，我们的绑定 <code>this</code><br>就需要“被忽略”，<code>this</code> 要绑定在实例上。也就是说，<code>new</code> 的操作符要高于 <code>bind</code> 绑定，兼容这种情况的实现：</p>
<pre><code>Function.prototype.bind = Function.prototype.bind || function (context) &#123;
    var me = this;
    var args = Array.prototype.slice.call(arguments, 1);
    var F = function () &#123;&#125;;
    F.prototype = this.prototype;
    var bound = function () &#123;
        var innerArgs = Array.prototype.slice.call(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(this instanceof F ? this : context || this, finalArgs);
    &#125;
    bound.prototype = new F();
    return bound;
&#125;</code></pre>
<p>如果你认为这样就完了，其实我会告诉你说，高潮才刚要上演。曾经的我也认为上述方法已经比较完美了，直到我看了 es5-shim 源码（已适当删减）：</p>
<pre><code>function bind(that) &#123;
    var target = this;
    if (!isCallable(target)) &#123;
        throw new TypeError(&#39;Function.prototype.bind called on incompatible &#39; + target);
    &#125;
    var args = array_slice.call(arguments, 1);
    var bound;
    var binder = function () &#123;
        if (this instanceof bound) &#123;
            var result = target.apply(
                this,
                array_concat.call(args, array_slice.call(arguments))
            );
            if ($Object(result) === result) &#123;
                return result;
            &#125;
            return this;
        &#125; else &#123;
            return target.apply(
                that,
                array_concat.call(args, array_slice.call(arguments))
            );
        &#125;
    &#125;;
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i &lt; boundLength; i++) &#123;
        array_push.call(boundArgs, &#39;$&#39; + i);
    &#125;
    bound = Function(&#39;binder&#39;, &#39;return function (&#39; + boundArgs.join(&#39;,&#39;) + &#39;)&#123; return binder.apply(this, arguments); &#125;&#39;)(binder);

    if (target.prototype) &#123;
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    &#125;
    return bound;
&#125;</code></pre>
<p>es5-shim 的实现到底在“搞什么鬼”呢？你可能不知道，其实每个函数都有 <code>length</code> 属性。对，就像数组和字符串那样。函数的 <code>length</code><br>属性，用于表示函数的形参个数。更重要的是函数的 <code>length</code> 属性值是不可重写的。我写了个测试代码来证明：</p>
<pre><code>function test ()&#123;&#125;
test.length  // 输出 0
test.hasOwnProperty(&#39;length&#39;)  // 输出 true
Object.getOwnPropertyDescriptor(&#39;test&#39;, &#39;length&#39;) 
// 输出：
// configurable: false, 
// enumerable: false,
// value: 4, 
// writable: false </code></pre>
<p>说到这里，那就好解释了： <strong>es5-shim 是为了最大限度地进行兼容，包括对返回函数<code>length</code><br>属性的还原</strong>。而如果按照我们之前实现的那种方式，<code>length</code> 值始终为零。因此，既然不能修改 <code>length</code><br>的属性值，那么在初始化时赋值总可以吧！于是我们可通过 <code>eval</code> 和 <code>new Function</code><br>的方式动态定义函数。但是出于安全考虑，在某些浏览器中使用 <code>eval</code> 或者 <code>Function()</code><br>构造函数都会抛出异常。然而巧合的是，这些无法兼容的浏览器基本上都实现了 <code>bind</code> 函数，这些异常又不会被触发。在上述代码里，重设绑定函数的<br><code>length</code> 属性：</p>
<pre><code>var boundLength = max(0, target.length - args.length)</code></pre>
<p>构造函数调用情况，在 <code>binder</code> 中也有效兼容：</p>
<pre><code>if (this instanceof bound) &#123; 
    ... // 构造函数调用情况
&#125; else &#123;
    ... // 正常方式调用
&#125;

if (target.prototype) &#123;
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    // 进行垃圾回收清理
    Empty.prototype = null;
&#125;</code></pre>
<p>对比过几版的 polyfill 实现，对于 <code>bind</code> 应该有了比较深刻的认识。这一系列实现有效地考察了很重要的知识点：比如 <code>this</code><br>的指向、JavaScript 闭包、原型与原型链，设计程序上的边界 case 和兼容性考虑经验等硬素质。</p>
<h4 id="一道更好的面试题"><a href="#一道更好的面试题" class="headerlink" title="一道更好的面试题"></a>一道更好的面试题</h4><p>最后，现如今在很多面试中，面试官都会以“实现 <code>bind</code>”作为题目。 <strong>如果是我，现在可能会规避这个很容易“应试”的题目，而是别出心裁，让面试者实现一个<br>“call/apply”</strong> 。我们往往用 <code>call</code>/<code>apply</code> 模拟实现 <code>bind</code>，而直接实现 <code>call</code>/<code>apply</code> 也算简单：</p>
<pre><code>Function.prototype.applyFn = function (targetObject, argsArray) &#123;
    if(typeof argsArray === &#39;undefined&#39; || argsArray === null) &#123;
        argsArray = []
    &#125;

    if(typeof targetObject === &#39;undefined&#39; || targetObject === null)&#123;
        targetObject = window
    &#125;

    targetObject = new Object(targetObject)

    const targetFnKey = &#39;targetFnKey&#39;
    targetObject[targetFnKey] = this

    const result = targetObject[targetFnKey](...argsArray)
    delete targetObject[targetFnKey]
    return result
&#125;</code></pre>
<p>这样的代码不难理解，函数体内的 <code>this</code> 指向了调用 <code>applyFn</code> 的函数。为了将该函数体内的 <code>this</code> 绑定在 <code>targetObject</code><br>上，我们采用了隐式绑定的方法：<code>targetObject[targetFnKey](...argsArray)</code>。</p>
<p>细心的读者会发现，这里存在一个问题：如果 <code>targetObject</code> 对象本身就存在 <code>targetFnKey</code> 这样的属性，那么在使用<br><code>applyFn</code> 函数时，原有的 <code>targetFnKey</code> 属性值就会被覆盖，之后被删除。解决方案可以使用 ES6 <code>Sybmol()</code><br>来保证键的唯一性；另一种解决方案是用 <code>Math.random()</code> 实现独一无二的 key，这里我们不再赘述。</p>
<h3 id="实现这些-API-带来的启示"><a href="#实现这些-API-带来的启示" class="headerlink" title="实现这些 API 带来的启示"></a>实现这些 API 带来的启示</h3><p>这些 API 的实现并不算复杂，却能恰如其分地考验开发者的 JavaScript<br>基础。基础是地基，是探究更深入内容的钥匙，是进阶之路上最重要的一环，需要每个开发者重视。在前端技术快速发展迭代的今天，在“前端市场是否饱和”，“前端求职火爆异常”，“前端入门简单，钱多人傻”等众说纷纭的浮躁环境下，对基础内功的修炼就显得尤为重要。这也是你在前端路上能走多远、走多久的关键。</p>
<p>从面试的角度看，面试题归根结底是对基础的考察，只有对基础烂熟于胸，才能具备突破面试的基本条件。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/HOUCe/lucas-gitchat-courses">课程代码仓库请单击这里查看</a>。</p>
<h3 id="分享交流"><a href="#分享交流" class="headerlink" title="分享交流"></a>分享交流</h3><p>请大家留言分享自己开发实践中遇到的「API」相关的难忘经历。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC<br>提问（作者看到后抽空解答）。 <strong>你的分享不仅帮助他人，更会提升自己。</strong></p>
<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>
<blockquote>
<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-<br>泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/advanced/005--%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%8C%E8%AF%B5%20API%EF%BC%8C%E5%8F%AA%E5%AE%9E%E7%8E%B0%20API/">https://jinxiaochuan.github.io/matrix/advanced/005--%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%8C%E8%AF%B5%20API%EF%BC%8C%E5%8F%AA%E5%AE%9E%E7%8E%B0%20API/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/advanced/003--%E8%80%81%E5%8F%B8%E6%9C%BA%E4%B9%9F%E4%BC%9A%E5%9C%A8%E9%97%AD%E5%8C%85%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9%E7%BF%BB%E8%BD%A6%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶03 | 老司机也会在闭包相关知识点翻车（上）</div></div></a></div><div class="next-post pull-right"><a href="/matrix/advanced/007--%E5%85%B6%E4%BB%96%E5%9F%BA%E7%A1%80%E9%A2%98%E5%BA%93/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶07 | 其他基础题库</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="this.onerror=null;this.src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#jQuery-offset-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">jQuery offset 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">1.1.</span> <span class="toc-text">递归实现方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getBoundingClientRect-%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">getBoundingClientRect 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-reduce-%E6%96%B9%E6%B3%95%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">数组 reduce 方法的相关实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-%E5%AE%9E%E7%8E%B0-runPromiseInSequence"><span class="toc-number">2.1.</span> <span class="toc-text">reduce 实现 runPromiseInSequence</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce-%E5%AE%9E%E7%8E%B0-pipe"><span class="toc-number">2.2.</span> <span class="toc-text">reduce 实现 pipe</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-reduce"><span class="toc-number">2.3.</span> <span class="toc-text">实现一个 reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-Koa-only-%E6%A8%A1%E5%9D%97%E6%BA%90%E7%A0%81%E8%AE%A4%E8%AF%86-reduce"><span class="toc-number">2.4.</span> <span class="toc-text">通过 Koa only 模块源码认识 reduce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compose-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">3.</span> <span class="toc-text">compose 实现的几种方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apply%E3%80%81bind-%E8%BF%9B%E9%98%B6%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.</span> <span class="toc-text">apply、bind 进阶实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E6%9B%B4%E5%A5%BD%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">一道更好的面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B-API-%E5%B8%A6%E6%9D%A5%E7%9A%84%E5%90%AF%E7%A4%BA"><span class="toc-number">5.</span> <span class="toc-text">实现这些 API 带来的启示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81"><span class="toc-number">6.</span> <span class="toc-text">分享交流</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/algorithm/" title="FE Algorithm - 阶乘"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-1ef0181f71fe1bd731f172ff3b0fc2d3_1200x500.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611282995&amp;t=42ae5101c61f264a349c808013a9c512" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶38 | 揭秘前端设计模式（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）">核心进阶38 | 揭秘前端设计模式（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）">核心进阶47 | 缓存谁都懂，一问都哑巴（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶49 | HTTP 的深思：我从何而来，去向何处"/></a><div class="content"><a class="title" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处">核心进阶49 | HTTP 的深思：我从何而来，去向何处</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶51 | 大话社区和一名技术者的自我修养"/></a><div class="content"><a class="title" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养">核心进阶51 | 大话社区和一名技术者的自我修养</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>