<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶22 | 同构应用中你所忽略的细节 | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个renderToString（React 中）类似的 API 吗？ 讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。 同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶22 | 同构应用中你所忽略的细节">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/advanced/022--%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%A0%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个renderToString（React 中）类似的 API 吗？ 讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。 同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360">
<meta property="article:published_time" content="2020-12-23T03:47:50.492Z">
<meta property="article:modified_time" content="2020-12-23T03:47:50.492Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&refer=http%3A%2F%2F00.minipic.eastday.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1611283231&t=82f18a3b7b8ad76bf906bc78635e5360"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/advanced/022--%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%A0%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-23 11:47:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="onerror=null;src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶22 | 同构应用中你所忽略的细节</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-23T03:47:50.492Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-23T03:47:50.492Z" title="更新于 2020-12-23 11:47:50">2020-12-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>不管是服务端渲染还是服务端渲染衍生出的同构应用，现在来看已经并不新鲜了，实现起来也并不困难。可是有的开发者认为：同构应用不就是调用一个<br>renderToString（React 中）类似的 API 吗？</p>
<p>讲道理确实是这样的，但是讲道理你也许并没有真正在实战中领会同构应用的精髓。</p>
<p>同构应用能够完成的本质条件是虚拟 DOM，基于虚拟 DOM 我们可以生成真实的 DOM，并由浏览器渲染；也可以调用不同框架的不同 APIs，将虚拟 DOM<br>生成字符串，由服务端传输给客户端。</p>
<p>但是同构应用也不只是这么简单。拿面试来说，同构应用的考察点不是“纸上谈兵”的理论，而是实际实施时的细节。这一讲我们就来聊一聊“同构应用中往往被忽略的细节”，需要读者提前了解服务端渲染和同构应用的概念。</p>
<p>相关知识点如下：</p>
<p><img src="https://images.gitbook.cn/d5314df0-9d55-11e9-8a2c-e9ea8cc9b822"></p>
<h3 id="打包环境区分"><a href="#打包环境区分" class="headerlink" title="打包环境区分"></a>打包环境区分</h3><p>第一个细节：我们知道同构应用实现了客户端代码和服务端代码的基本统一，我们只需要编写一种组件，就能生成适用于服务端和客户端的组件案例。可是你是否知道，服务端代码和客户端代码大多数情况下还是需要单独处理？比如：</p>
<ul>
<li>路由代码差别：服务端需要根据请求路径，匹配页面组件；客户端需要通过浏览器中的地址，匹配页面组件。</li>
</ul>
<p>客户端代码：</p>
<pre><code>const App = () =&gt; &#123;
  return (
    &lt;Provider store=&#123;store&#125;&gt;
      &lt;BrowserRouter&gt;
        &lt;div&gt;
          &lt;Route path=&#39;/&#39; component=&#123;Home&#125;&gt;
          &lt;Route path=&#39;/product&#39; component=&#123;Product&#125;&gt;
        &lt;/div&gt;
      &lt;/BrowserRouter&gt;
    &lt;/Provider&gt;
  )
&#125;
ReactDom.render(&lt;App/&gt;, document.querySelector(&#39;#root&#39;))</code></pre>
<p>BrowserRouter 组件根据 window.location 以及 history API 实现页面切换，而服务端肯定是无法获取<br>window.location 的，服务端代码如下：</p>
<pre><code>const App = () =&gt; &#123;
  return 
    &lt;Provider store=&#123;store&#125;&gt;
      &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;
        &lt;div&gt;
          &lt;Route path=&#39;/&#39; component=&#123;Home&#125;&gt;
        &lt;/div&gt;
      &lt;/StaticRouter&gt;
    &lt;/Provider&gt;
&#125;
Return ReactDom.renderToString(&lt;App/&gt;)</code></pre>
<p>需要使用 StaticRouter 组件，并将请求地址和上下文信息作为 location 和 context 这两个 props 传入<br>StaticRouter 中。</p>
<ul>
<li><p>打包差别：服务端运行的代码如果需要依赖 Node 核心模块或者第三方模块，就不再需要把这些模块代码打包到最终代码中了。因为环境已经安装这些依赖，可以直接引用。这样一来，就需要我们在 webpack 中配置：target：node，并借助 webpack-node-externals 插件，解决第三方依赖打包的问题。</p>
</li>
<li><p>对于图片等静态资源，url-loader 会在服务端代码和客户端代码打包过程中分别被引用，因此会在资源目录中生成了重复的文件。当然后打包出来的因为重名，会覆盖前一次打包出来的结果，并不影响使用，但是整个构建过程并不优雅。</p>
</li>
<li><p>由于路由在服务端和客户端的差别，因此 webpack 配置文件的 entry 会不相同：</p>
</li>
</ul>
<pre><code>&#123;
    entry: &#39;./src/client/index.js&#39;,
&#125;

&#123;
    entry: &#39;./src/server/index.js&#39;,
&#125;</code></pre>
<h3 id="注水和脱水"><a href="#注水和脱水" class="headerlink" title="注水和脱水"></a>注水和脱水</h3><p>什么叫做注水和脱水呢？这个和同构应用中数据的获取有关：在服务器端渲染时，首先服务端请求接口拿到数据，并处理准备好数据状态（如果使用 Redux，就是进行<br>store 的更新），为了减少客户端的请求，我们需要保留住这个状态。一般做法是在服务器端返回 HTML 字符串的时候，将数据 JSON.stringify<br>一并返回，这个过程，叫做脱水（dehydrate）；在客户端，就不再需要进行数据的请求了，可以直接使用服务端下发下来的数据，这个过程叫注水（hydrate）。用代码来表示：</p>
<p>服务端：</p>
<pre><code>ctx.body = `
  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
        window.context = &#123;
          initialState: $&#123;JSON.stringify(store.getState())&#125;
        &#125;
      &lt;/script&gt;
      &lt;div id=&quot;app&quot;&gt;
          // ...
      &lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;
`</code></pre>
<p>客户端：</p>
<pre><code>export const getClientStore = () =&gt; &#123;
  const defaultState = JSON.parse(window.context.state)
  return createStore(reducer, defaultState, applyMiddleware(thunk))
&#125;</code></pre>
<p>这一系列过程非常典型，但是也会有几个细节值得探讨： <strong>在服务端渲染时，服务端如何能够请求所有的 APIs，保障数据全部已经请求呢？</strong></p>
<p>一般有两种方法：</p>
<ul>
<li>react-router 的解决方案是配置路由 route-config，结合 matchRoutes，找到页面上相关组件所需的请求接口的方法并执行请求。这就要求开发者通过路由配置信息，显式地告知服务端请求内容。</li>
</ul>
<p>我们首先配置路由：</p>
<pre><code>const routes = [
  &#123;
    path: &quot;/&quot;,
    component: Root,
    loadData: () =&gt; getSomeData()
  &#125;
  // etc.
]

import &#123; routes &#125; from &quot;./routes&quot;

function App() &#123;
  return (
    &lt;Switch&gt;
      &#123;routes.map(route =&gt; (
        &lt;Route &#123;...route&#125; /&gt;
      ))&#125;
    &lt;/Switch&gt;
  )
&#125;</code></pre>
<p>在服务端代码中：</p>
<pre><code>import &#123; matchPath &#125; from &quot;react-router-dom&quot;

const promises = []
routes.some(route =&gt; &#123;
  const match = matchPath(req.path, route)
  if (match) promises.push(route.loadData(match))
  return match
&#125;)

Promise.all(promises).then(data =&gt; &#123;
  putTheDataSomewhereTheClientCanFindIt(data)
&#125;)</code></pre>
<ul>
<li>另外一种思路类似 Next.js，我们需要在 React 组件上定义静态方法。 比如定义静态 loadData 方法，在服务端渲染时，我们可以遍历所有组件的 loadData，获取需要请求的接口。这样的方式借鉴了早期 React-apollo 的解决方案，我个人很喜欢这种设计。这里贴出我为 Facebook 团队 react-apollo 开源项目贡献的改动代码，其目的就是遍历组件，获取请求接口：</li>
</ul>
<pre><code>function getPromisesFromTree(&#123;
  rootElement,
  rootContext = &#123;&#125;,
&#125;: PromiseTreeArgument): PromiseTreeResult[] &#123;
  const promises: PromiseTreeResult[] = [];

  walkTree(rootElement, rootContext, (_, instance, context, childContext) =&gt; &#123;
    if (instance &amp;&amp; hasFetchDataFunction(instance)) &#123;
      const promise = instance.fetchData();
      if (isPromise&lt;Object&gt;(promise)) &#123;
        promises.push(&#123; promise, context: childContext || context, instance &#125;);
        return false;
      &#125;
    &#125;
  &#125;);

  return promises;
&#125;

// Recurse a React Element tree, running visitor on each element.
// If visitor returns `false`, don&#39;t call the element&#39;s render function
// or recurse into its child elements.
export function walkTree(
  element: React.ReactNode,
  context: Context,
  visitor: (
    element: React.ReactNode,
    instance: React.Component&lt;any&gt; | null,
    context: Context,
    childContext?: Context,
  ) =&gt; boolean | void,
) &#123;
  if (Array.isArray(element)) &#123;
    element.forEach(item =&gt; walkTree(item, context, visitor));
    return;
  &#125;

  if (!element) &#123;
    return;
  &#125;

  // A stateless functional component or a class
  if (isReactElement(element)) &#123;
    if (typeof element.type === &#39;function&#39;) &#123;
      const Comp = element.type;
      const props = Object.assign(&#123;&#125;, Comp.defaultProps, getProps(element));
      let childContext = context;
      let child;

      // Are we are a react class?
      if (isComponentClass(Comp)) &#123;
        const instance = new Comp(props, context);
        // In case the user doesn&#39;t pass these to super in the constructor.
        // Note: `Component.props` are now readonly in `@types/react`, so
        // we&#39;re using `defineProperty` as a workaround (for now).
        Object.defineProperty(instance, &#39;props&#39;, &#123;
          value: instance.props || props,
        &#125;);
        instance.context = instance.context || context;

        // Set the instance state to null (not undefined) if not set, to match React behaviour
        instance.state = instance.state || null;

        // Override setState to just change the state, not queue up an update
        // (we can&#39;t do the default React thing as we aren&#39;t mounted
        // &quot;properly&quot;, however we don&#39;t need to re-render as we only support
        // setState in componentWillMount, which happens *before* render).
        instance.setState = newState =&gt; &#123;
          if (typeof newState === &#39;function&#39;) &#123;
            // React&#39;s TS type definitions don&#39;t contain context as a third parameter for
            // setState&#39;s updater function.
            // Remove this cast to `any` when that is fixed.
            newState = (newState as any)(instance.state, instance.props, instance.context);
          &#125;
          instance.state = Object.assign(&#123;&#125;, instance.state, newState);
        &#125;;

        if (Comp.getDerivedStateFromProps) &#123;
          const result = Comp.getDerivedStateFromProps(instance.props, instance.state);
          if (result !== null) &#123;
            instance.state = Object.assign(&#123;&#125;, instance.state, result);
          &#125;
        &#125; else if (instance.UNSAFE_componentWillMount) &#123;
          instance.UNSAFE_componentWillMount();
        &#125; else if (instance.componentWillMount) &#123;
          instance.componentWillMount();
        &#125;

        if (providesChildContext(instance)) &#123;
          childContext = Object.assign(&#123;&#125;, context, instance.getChildContext());
        &#125;

        if (visitor(element, instance, context, childContext) === false) &#123;
          return;
        &#125;

        child = instance.render();
      &#125; else &#123;
        // Just a stateless functional
        if (visitor(element, null, context) === false) &#123;
          return;
        &#125;

        child = Comp(props, context);
      &#125;

      if (child) &#123;
        if (Array.isArray(child)) &#123;
          child.forEach(item =&gt; walkTree(item, childContext, visitor));
        &#125; else &#123;
          walkTree(child, childContext, visitor);
        &#125;
      &#125;
    &#125; else if ((element.type as any)._context || (element.type as any).Consumer) &#123;
      // A React context provider or consumer
      if (visitor(element, null, context) === false) &#123;
        return;
      &#125;

      let child;
      if ((element.type as any)._context) &#123;
        // A provider - sets the context value before rendering children
        ((element.type as any)._context as any)._currentValue = element.props.value;
        child = element.props.children;
      &#125; else &#123;
        // A consumer
        child = element.props.children((element.type as any)._currentValue);
      &#125;

      if (child) &#123;
        if (Array.isArray(child)) &#123;
          child.forEach(item =&gt; walkTree(item, context, visitor));
        &#125; else &#123;
          walkTree(child, context, visitor);
        &#125;
      &#125;
    &#125; else &#123;
      // A basic string or dom element, just get children
      if (visitor(element, null, context) === false) &#123;
        return;
      &#125;

      if (element.props &amp;&amp; element.props.children) &#123;
        React.Children.forEach(element.props.children, (child: any) =&gt; &#123;
          if (child) &#123;
            walkTree(child, context, visitor);
          &#125;
        &#125;);
      &#125;
    &#125;
  &#125; else if (typeof element === &#39;string&#39; || typeof element === &#39;number&#39;) &#123;
    // Just visit these, they are leaves so we don&#39;t keep traversing.
    visitor(element, null, context);
  &#125;
&#125;</code></pre>
<p>注水和脱水，是同构应用最为核心和关键的细节点。</p>
<h3 id="请求认证处理"><a href="#请求认证处理" class="headerlink" title="请求认证处理"></a>请求认证处理</h3><p>上面讲到服务端预先请求数据，那么思考这样的场景：某个请求依赖 cookie<br>表明的用户信息，比如请求“我的学习计划列表”。这种情况下服务端请求是不同于客户端的，不会有浏览器添加 cookie 以及不含有其他相关的 header<br>信息。这个请求在服务端发送时，一定不会拿到预期的结果。</p>
<p>为了解决这个问题，我们来看看 React-apollo 的解决方法：</p>
<pre><code>import &#123; ApolloProvider &#125; from &#39;react-apollo&#39;
import &#123; ApolloClient &#125; from &#39;apollo-client&#39;
import &#123; createHttpLink &#125; from &#39;apollo-link-http&#39;
import Express from &#39;express&#39;
import &#123; StaticRouter &#125; from &#39;react-router&#39;
import &#123; InMemoryCache &#125; from &quot;apollo-cache-inmemory&quot;

import Layout from &#39;./routes/Layout&#39;

// Note you don&#39;t have to use any particular http server, but
// we&#39;re using Express in this example
const app = new Express();
app.use((req, res) =&gt; &#123;

  const client = new ApolloClient(&#123;
    ssrMode: true,
    // Remember that this is the interface the SSR server will use to connect to the
    // API server, so we need to ensure it isn&#39;t firewalled, etc
    link: createHttpLink(&#123;
      uri: &#39;http://localhost:3010&#39;,
      credentials: &#39;same-origin&#39;,
      headers: &#123;
        cookie: req.header(&#39;Cookie&#39;),
      &#125;,
    &#125;),
    cache: new InMemoryCache(),
  &#125;);

  const context = &#123;&#125;

  // The client-side App will instead use &lt;BrowserRouter&gt;
  const App = (
    &lt;ApolloProvider client=&#123;client&#125;&gt;
      &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;
        &lt;Layout /&gt;
      &lt;/StaticRouter&gt;
    &lt;/ApolloProvider&gt;
  );

  // rendering code (see below)
&#125;)</code></pre>
<p>这个做法也非常简单，原理是：服务端请求时需要保留客户端页面请求的信息，并在 API 请求时携带并透传这个信息。上述代码中，createHttpLink<br>方法调用时：</p>
<pre><code>headers: &#123;
    cookie: req.header(&#39;Cookie&#39;),
&#125;,</code></pre>
<p>这个配置项就是关键，它使得服务端的请求完整地还原了客户端信息，因此验证类接口也不再会有问题。</p>
<p>事实上，很多早期 React 完成服务端渲染的轮子都借鉴了 React-apollo 众多优秀思想，对这个话题感兴趣的读者可以抽空去了解 React-<br>apollo。</p>
<h3 id="样式问题处理"><a href="#样式问题处理" class="headerlink" title="样式问题处理"></a>样式问题处理</h3><p>同构应用的样式处理容易被开发者所忽视，而一旦忽略，就会掉到坑里。比如，正常的服务端渲染只是返回了 HTML 字符串，样式需要浏览器加载完 CSS<br>后才会加上，这个样式添加的过程就会造成页面的闪动。</p>
<p>再比如，我们不能再使用 style-loader 了，因为这个 webpack loader 会在编译时将样式模块载入到 HTML header<br>中。但是在服务端渲染环境下，没有 window 对象，style-loader 进而会报错。一般我们换用 isomorphic-style-loader<br>来实现：</p>
<pre><code>&#123;
    test: /\.css$/,
    use: [
        &#39;isomorphic-style-loader&#39;,
        &#39;css-loader&#39;,
        &#39;postcss-loader&#39;
    ],
&#125;</code></pre>
<p>同时 isomorphic-style-loader 也会解决页面样式闪动的问题。它的原理也不难理解：在服务器端输出 html 字符串的同时，也将样式插入到<br>html 字符串当中，将结果一同传送到客户端。</p>
<p>isomorphic-style-loader 的原理是什么呢？</p>
<p>我们知道对于 webpack 来说，所有的资源都是模块，webpack loader 在编译过程中可以将导入的 CSS 文件转换成对象，拿到样式信息。因此<br>isomorphic-style-loader 可以获取页面中所有组件样式。为了实现的更加通用化，isomorphic-style-loader 利用<br>context API，在渲染页面组件时获取所有 React 组件的样式信息，最终插入到 HTML 字符串中。</p>
<p>在服务端渲染时，我们需要加入这样的逻辑：</p>
<pre><code>import express from &#39;express&#39;
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;
import StyleContext from &#39;isomorphic-style-loader/StyleContext&#39;
import App from &#39;./App.js&#39;

const server = express()
const port = process.env.PORT || 3000

// Server-side rendering of the React app
server.get(&#39;*&#39;, (req, res, next) =&gt; &#123;

  const css = new Set() // CSS for all rendered React components

  const insertCss = (...styles) =&gt; styles.forEach(style =&gt; css.add(style._getCss()))

  const body = ReactDOM.renderToString(
    &lt;StyleContext.Provider value=&#123;&#123; insertCss &#125;&#125;&gt;
      &lt;App /&gt;
    &lt;/StyleContext.Provider&gt;
  )
  const html = `&lt;!doctype html&gt;
    &lt;html&gt;
      &lt;head&gt;
        &lt;script src=&quot;client.js&quot; defer&gt;&lt;/script&gt;
        &lt;style&gt;$&#123;[...css].join(&#39;&#39;)&#125;&lt;/style&gt;
      &lt;/head&gt;
      &lt;body&gt;
        &lt;div id=&quot;root&quot;&gt;$&#123;body&#125;&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;`
  res.status(200).send(html)
&#125;)

server.listen(port, () =&gt; &#123;
  console.log(`Node.js app is running at http://localhost:$&#123;port&#125;/`)
&#125;)</code></pre>
<p>我们定义了 css Set 类型来存储页面所有的样式，并定义了 insertCss 方法，该方法通过 context 传给每个 React<br>组件，这样每个组件就可以调用 insertCss 方法。该方法调用时，会将组件样式加入到 css Set 当中。</p>
<p>最后我们用 […css].join(‘’) 就可以获取页面的所有样式字符串。</p>
<p>强调一下，isomorphic-style-loader 的源码目前已经更新，采用了最新的 React hooks API，我推荐给 React<br>开发者阅读，相信一定收获很多！</p>
<h3 id="meta-tags-渲染"><a href="#meta-tags-渲染" class="headerlink" title="meta tags 渲染"></a>meta tags 渲染</h3><p>React 应用中，骨架往往类似：</p>
<pre><code>const App = () =&gt; &#123;
  return (
    &lt;div&gt;
       &lt;Component1 /&gt;
       &lt;Component2 /&gt;
    &lt;/div&gt;
  )
&#125;
ReactDom.render(&lt;App/&gt;, document.querySelector(&#39;#root&#39;))</code></pre>
<p>App 组件嵌入到 document.querySelector(‘#root’) 节点当中，一般是不包含 head<br>标签的。但是单页应用在切换路由时，可能也会需要动态修改 head 标签信息，比如 title<br>内容。也就是说：在单页面应用切换页面，不会经过服务端渲染，但是我们仍然需要更改 document 的 title 内容。</p>
<p>那么服务端如何渲染 meta tags head 标签就是一个常被忽略但是至关重要的话题，我们往往使用 React-helmet 库来解决问题。</p>
<p>Home 组件：</p>
<pre><code>import Helmet from &quot;react-helmet&quot;;

&lt;div&gt;
    &lt;Helmet&gt;
        &lt;title&gt;Home page&lt;/title&gt;
        &lt;meta name=&quot;description&quot; content=&quot;Home page description&quot; /&gt;
    &lt;/Helmet&gt;
    &lt;h1&gt;Home component&lt;/h1&gt;</code></pre>
<p>Users 组件：</p>
<pre><code>&lt;Helmet&gt;
    &lt;title&gt;Users page&lt;/title&gt;
    &lt;meta name=&quot;description&quot; content=&quot;Users page description&quot; /&gt;
&lt;/Helmet&gt;</code></pre>
<p>React-helmet 这个库会在 Home 组件和 Users 组件渲染时，检测到 Helmet，并自动执行副作用逻辑。</p>
<h3 id="404-处理"><a href="#404-处理" class="headerlink" title="404 处理"></a>404 处理</h3><p>当服务端渲染时，我们还需要留心对 404 的情况进行处理，有 layout.js 文件如下：</p>
<pre><code>&lt;Switch&gt;
    &lt;Route path=&quot;/&quot; exact component=&#123;Home&#125; /&gt;
    &lt;Route path=&quot;/users&quot; exact component=&#123;Users&#125; /&gt;
&lt;/Switch&gt;</code></pre>
<p>当访问：<code>/home</code> 时，会得到一个空白页面，浏览器也没有得到 404 的状态码。为了处理这种情况，我们加入：</p>
<pre><code>&lt;Switch&gt;
    &lt;Route path=&quot;/&quot; exact component=&#123;Home&#125; /&gt;
    &lt;Route path=&quot;/users&quot; exact component=&#123;Users&#125; /&gt;
    &lt;Route component=&#123;NotFound&#125; /&gt;
&lt;/Switch&gt;</code></pre>
<p>并创建 NotFound.js 文件：</p>
<pre><code>import React from &#39;react&#39;

export default function NotFound(&#123; staticContext &#125;) &#123;
    if (staticContext) &#123;
        staticContext.notFound = true
    &#125;
    return (
        &lt;div&gt;Not found&lt;/div&gt;
    )
&#125;</code></pre>
<p>注意，在访问一个不存在的地址时，我们要返回 404 状态码。一般 React router 类库已经帮我们进行了较好的封装，Static Router<br>会注入一个 context prop，并将 context.notFound 赋值为 true，在 server/index.js 加入：</p>
<pre><code>const context = &#123;&#125;
const html = renderer(data, req.path, context);
if (context.notFound) &#123;
    res.status(404)
&#125;
res.send(html)</code></pre>
<p>即可。这一系列处理过程没有什么难点，但是这种处理意识，还是需要具备的。</p>
<h3 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h3><p>安全问题非常关键，尤其是涉及到服务端渲染，开发者要格外小心。这里提出一个点：我们前面提到了注水和脱水过程，其中的代码：</p>
<pre><code>ctx.body = `
  &lt;!DOCTYPE html&gt;
  &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
      &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script&gt;
        window.context = &#123;
          initialState: $&#123;JSON.stringify(store.getState())&#125;
        &#125;
      &lt;/script&gt;
      &lt;div id=&quot;app&quot;&gt;
          // ...
      &lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;
`</code></pre>
<p>非常容易遭受 XSS 攻击，JSON.stringify 可能会造成 script 注入。因此，我们需要严格清洗 JSON 字符串中的 HTML<br>标签和其他危险的字符。我习惯使用 serialize-javascript 库进行处理，这也是同构应用中最容易被忽视的细节。</p>
<p>这里给大家留一个思考题，React dangerouslySetInnerHTML API 也有类似风险，React 是怎么处理这个安全隐患的呢？</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>我们将数据请求移到了服务端，但是依然要格外重视性能优化。目前针对于此，业界普遍做法包括以下几点。</p>
<ul>
<li>使用缓存：服务端优化一个最重要的手段就是缓存，不同于传统服务端缓存措施，我们甚至可以实现组件级缓存，业界 walmartlabs 在这方面的实践非常多，且收获了较大的性能提升。感兴趣的读者可以找到相关技术信息。</li>
<li>采用 HSF 代替 HTTP，HSF 是 High-Speed Service Framework 的缩写，译为分布式的远程服务调用框架，对外提供服务上，HSF 性能远超过 HTTP。</li>
<li>对于服务端压力过大的场景，动态切换为客户端渲染。</li>
<li>NodeJS 升级。</li>
<li>React 升级。</li>
</ul>
<p>如图所示，React 16 在服务端渲染上的性能对比提升：</p>
<p><img src="https://images.gitbook.cn/62d9e840-9ee8-11e9-ac5c-d5048fafc34b" alt="enter image description
here"></p>
<blockquote>
<p>备注：图片来自 [hacker noon](<a target="_blank" rel="noopener" href="https://hackernoon.com/whats-new-with-server-side-">https://hackernoon.com/whats-new-with-server-side-</a><br>rendering-in-react-16-9b0d78585d67)</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本讲没有“手把手”教你实现服务端渲染的同构应用，因为这些知识并不困难，社区上资料也很多。我们从更高的角度出发，剖析同构应用中那些关键的细节点和疑难问题的解决方案，这些经验来源于真刀真枪的线上案例，如果读者没有开发过同构应用，也能从中全方位地了解关键信息，一旦掌握了这些细节，同构应用的实现就会更稳、更可靠。</p>
<p>同构应用其实远比理论复杂，绝对不是几个 APIs 和几台服务器就能完成的，希望大家多思考、多动手，一定会更有体会。</p>
<p>另外，同构应用各种细节也不止于此，坑也不止于此，欢迎大家和我讨论。</p>
<h3 id="分享交流"><a href="#分享交流" class="headerlink" title="分享交流"></a>分享交流</h3><p>阅读文章过程中有任何疑问可随时跟其他小伙伴讨论，或者直接向作者 LucasHC 提问（作者看到后抽空回复）。 <strong>你的分享不仅帮助他人，更会提升自己。</strong></p>
<p>你也可以说说自己最想了解的主题，课程内容会根据部分读者的意见和建议迭代和完善。</p>
<blockquote>
<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-<br>泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/advanced/022--%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%A0%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82/">https://jinxiaochuan.github.io/matrix/advanced/022--%E5%90%8C%E6%9E%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%A0%E6%89%80%E5%BF%BD%E7%95%A5%E7%9A%84%E7%BB%86%E8%8A%82/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/advanced/021--React%20%E7%9A%84%E7%8E%B0%E7%8A%B6%E4%B8%8E%E6%9C%AA%E6%9D%A5/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶21 | React 的现状与未来</div></div></a></div><div class="next-post pull-right"><a href="/matrix/advanced/026--webpack%20%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%92%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="onerror=null;src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶26 | webpack 工程师和前端工程师（上）</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.byai.com/static/oss-script/24f46d0537131bf25d5519070dbfd06d.jpeg?x-oss-process=image/crop,x_0,y_120,w_1000,h_1000" onerror="this.onerror=null;this.src='https://ss0.baidu.com/94o3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D680%2C800/sign=23605bff60600c33f02cd6ce227c7d37/b64543a98226cffc56142759b2014a90f603ea1b.jpg'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E7%8E%AF%E5%A2%83%E5%8C%BA%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">打包环境区分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%B0%B4%E5%92%8C%E8%84%B1%E6%B0%B4"><span class="toc-number">2.</span> <span class="toc-text">注水和脱水</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%AE%A4%E8%AF%81%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">请求认证处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E5%BC%8F%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">样式问题处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#meta-tags-%E6%B8%B2%E6%9F%93"><span class="toc-number">5.</span> <span class="toc-text">meta tags 渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#404-%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">404 处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81"><span class="toc-number">10.</span> <span class="toc-text">分享交流</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/algorithm/" title="FE Algorithm - 阶乘"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-1ef0181f71fe1bd731f172ff3b0fc2d3_1200x500.jpg&amp;refer=http%3A%2F%2Fpic4.zhimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611282995&amp;t=42ae5101c61f264a349c808013a9c512" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶38 | 揭秘前端设计模式（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/038--%E6%8F%AD%E7%A7%98%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶38 | 揭秘前端设计模式（上）">核心进阶38 | 揭秘前端设计模式（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶47 | 缓存谁都懂，一问都哑巴（上）"/></a><div class="content"><a class="title" href="/matrix/advanced/047--%E7%BC%93%E5%AD%98%E8%B0%81%E9%83%BD%E6%87%82%EF%BC%8C%E4%B8%80%E9%97%AE%E9%83%BD%E5%93%91%E5%B7%B4%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶47 | 缓存谁都懂，一问都哑巴（上）">核心进阶47 | 缓存谁都懂，一问都哑巴（上）</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶49 | HTTP 的深思：我从何而来，去向何处"/></a><div class="content"><a class="title" href="/matrix/advanced/049--HTTP%20%E7%9A%84%E6%B7%B1%E6%80%9D%EF%BC%9A%E6%88%91%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5%EF%BC%8C%E5%8E%BB%E5%90%91%E4%BD%95%E5%A4%84/" title="核心进阶49 | HTTP 的深思：我从何而来，去向何处">核心进阶49 | HTTP 的深思：我从何而来，去向何处</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2F00.minipic.eastday.com%2F20170818%2F20170818115256_d41d8cd98f00b204e9800998ecf8427e_1.jpeg&amp;refer=http%3A%2F%2F00.minipic.eastday.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1611283231&amp;t=82f18a3b7b8ad76bf906bc78635e5360" onerror="this.onerror=null;this.src='https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1142711901,1643279206&amp;fm=26&amp;gp=0.jpg'" alt="核心进阶51 | 大话社区和一名技术者的自我修养"/></a><div class="content"><a class="title" href="/matrix/advanced/051--%E5%A4%A7%E8%AF%9D%E7%A4%BE%E5%8C%BA%E5%92%8C%E4%B8%80%E5%90%8D%E6%8A%80%E6%9C%AF%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" title="核心进阶51 | 大话社区和一名技术者的自我修养">核心进阶51 | 大话社区和一名技术者的自我修养</a><time datetime="2020-12-23T03:47:50.496Z" title="发表于 2020-12-23 11:47:50">2020-12-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>