<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>核心进阶31 | 代码规范工具及背后技术设计（下） | Matrix</title><meta name="author" content="小川"><meta name="copyright" content="小川"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。 在此之前，我们先回顾一下「代码规范」主题的知识点：  工具背后的技术原理和设计这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST已经不是一个新鲜话题，我们在 webpack 章节就">
<meta property="og:type" content="article">
<meta property="og:title" content="核心进阶31 | 代码规范工具及背后技术设计（下）">
<meta property="og:url" content="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/031--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="Matrix">
<meta property="og:description" content="上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。 在此之前，我们先回顾一下「代码规范」主题的知识点：  工具背后的技术原理和设计这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST已经不是一个新鲜话题，我们在 webpack 章节就">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg">
<meta property="article:published_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:modified_time" content="2020-12-22T12:51:17.444Z">
<meta property="article:author" content="小川">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg"><link rel="shortcut icon" href="/matrix/img/favicon.png"><link rel="canonical" href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/031--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/matrix/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/matrix/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-22 20:51:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/matrix/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div></div><hr/></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/matrix/">Matrix</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">核心进阶31 | 代码规范工具及背后技术设计（下）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-22T12:51:17.444Z" title="更新于 2020-12-22 20:51:17">2020-12-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>上一节课，我们主要介绍了代码规范工具，了解了它们的配置、使用方式。这一节，我们将深入原理，并根据其实现和扩展能力，开发更加灵活的工具集。</p>
<p>在此之前，我们先回顾一下「代码规范」主题的知识点：</p>
<p><img src="https://images.gitbook.cn/725e5a90-4ec9-11e9-b0b8-a9c8a3696845"></p>
<h3 id="工具背后的技术原理和设计"><a href="#工具背后的技术原理和设计" class="headerlink" title="工具背后的技术原理和设计"></a>工具背后的技术原理和设计</h3><p>这一小节，我们挑选实现更为复杂精妙的 ESLint 来分析。大家都清楚 ESLint 是基于静态语法分析（AST）进行工作的，AST<br>已经不是一个新鲜话题，我们在 webpack 章节就有介绍。ESLint 使用 Espree 来解析 JavaScript 语句，生成<br>AST。有了完整的解析树，我们就可以基于解析树对代码进行检测和修改。</p>
<p>ESLint 的灵魂是每一条 rule，每条规则都是独立且插件化的，我们挑一个比较简单的“禁止块级注释规则”源码来分析：</p>
<pre><code>module.exports = &#123;
  meta: &#123;
    docs: &#123;
      description: &#39;禁止块级注释&#39;,
      category: &#39;Stylistic Issues&#39;,
      recommended: true    
    &#125;
  &#125;,
  create (context) &#123;
    const sourceCode = context.getSourceCode()
    return &#123;
      Program () &#123;
        const comments = sourceCode.getAllComments()
        const blockComments = comments.filter((&#123; type &#125;) =&gt; type === &#39;Block&#39;)
        blockComments.length &amp;&amp; context.report(&#123;
          message: &#39;No block comments&#39;
        &#125;)
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
<p>从中我们看出，一条规则就是一个 node 模块，它由 meta 和 create 组成。meta 包含了该条规则的文档描述，相对简单。而 create<br>接受一个 context 参数，返回一个对象：</p>
<pre><code>&#123;
    meta: &#123;
        docs: &#123;
            description: &#39;禁止块级注释&#39;,
            category: &#39;Stylistic Issues&#39;,
            recommended: true 
        &#125;
    &#125;,
    create (context) &#123;
        // ...
        return &#123;

        &#125;
    &#125;
&#125;</code></pre>
<p>从 context 对象上我们可以取得当前执行扫描到的代码，并通过选择器获取当前需要的内容。如上代码，我们获取代码的所有<br>comments（sourceCode.getAllComments()），如果 blockComments 长度大于 0，则 report No<br>block comments 信息。</p>
<p>我们再来看一个 no-console rule 的实现：</p>
<pre><code>&quot;use strict&quot;;

module.exports = &#123;
    meta: &#123;
        type: &quot;suggestion&quot;,

        docs: &#123;
            description: &quot;disallow the use of `console`&quot;,
            category: &quot;Possible Errors&quot;,
            recommended: false,
            url: &quot;https://eslint.org/docs/rules/no-console&quot;
        &#125;,

        schema: [
            &#123;
                type: &quot;object&quot;,
                properties: &#123;
                    allow: &#123;
                        type: &quot;array&quot;,
                        items: &#123;
                            type: &quot;string&quot;
                        &#125;,
                        minItems: 1,
                        uniqueItems: true
                    &#125;
                &#125;,
                additionalProperties: false
            &#125;
        ],

        messages: &#123;
            unexpected: &quot;Unexpected console statement.&quot;
        &#125;
    &#125;,

    create(context) &#123;
        const options = context.options[0] || &#123;&#125;;
        const allowed = options.allow || [];

        /**
         * Checks whether the given reference is &#39;console&#39; or not.
         *
         * @param &#123;eslint-scope.Reference&#125; reference - The reference to check.
         * @returns &#123;boolean&#125; `true` if the reference is &#39;console&#39;.
         */
        function isConsole(reference) &#123;
            const id = reference.identifier;

            return id &amp;&amp; id.name === &quot;console&quot;;
        &#125;

        /**
         * Checks whether the property name of the given MemberExpression node
         * is allowed by options or not.
         *
         * @param &#123;ASTNode&#125; node - The MemberExpression node to check.
         * @returns &#123;boolean&#125; `true` if the property name of the node is allowed.
         */
        function isAllowed(node) &#123;
            const propertyName = astUtils.getStaticPropertyName(node);

            return propertyName &amp;&amp; allowed.indexOf(propertyName) !== -1;
        &#125;

        /**
         * Checks whether the given reference is a member access which is not
         * allowed by options or not.
         *
         * @param &#123;eslint-scope.Reference&#125; reference - The reference to check.
         * @returns &#123;boolean&#125; `true` if the reference is a member access which
         *      is not allowed by options.
         */
        function isMemberAccessExceptAllowed(reference) &#123;
            const node = reference.identifier;
            const parent = node.parent;

            return (
                parent.type === &quot;MemberExpression&quot; &amp;&amp;
                parent.object === node &amp;&amp;
                !isAllowed(parent)
            );
        &#125;

        /**
         * Reports the given reference as a violation.
         *
         * @param &#123;eslint-scope.Reference&#125; reference - The reference to report.
         * @returns &#123;void&#125;
         */
        function report(reference) &#123;
            const node = reference.identifier.parent;

            context.report(&#123;
                node,
                loc: node.loc,
                messageId: &quot;unexpected&quot;
            &#125;);
        &#125;

        return &#123;
            &quot;Program:exit&quot;() &#123;
                const scope = context.getScope();
                const consoleVar = astUtils.getVariableByName(scope, &quot;console&quot;);
                const shadowed = consoleVar &amp;&amp; consoleVar.defs.length &gt; 0;

                /*
                 * &#39;scope.through&#39; includes all references to undefined
                 * variables. If the variable &#39;console&#39; is not defined, it uses
                 * &#39;scope.through&#39;.
                 */
                const references = consoleVar
                    ? consoleVar.references
                    : scope.through.filter(isConsole);

                if (!shadowed) &#123;
                    references
                        .filter(isMemberAccessExceptAllowed)
                        .forEach(report);
                &#125;
            &#125;
        &#125;;
    &#125;
&#125;;</code></pre>
<p>代码中通过 astUtils.getVariableByName(scope, “console”) 以及 isConsole 函数来判别 console<br>语句的出现，通过 allowed.indexOf(propertyName) !== -1 来过滤白名单。</p>
<p>实现非常简单，了解了这些，相信你也能写出 no-alert，no-debugger 的规则内容。</p>
<p>我们再来看一下 no-duplicate-case 规则，它监测 switch…case 中是否存在相同的 case 分支：</p>
<pre><code>module.exports = &#123;
    meta: &#123;
        type: &quot;problem&quot;,

        docs: &#123;
            description: &quot;disallow duplicate case labels&quot;,
            category: &quot;Possible Errors&quot;,
            recommended: true,
            url: &quot;https://eslint.org/docs/rules/no-duplicate-case&quot;
        &#125;,

        schema: [],

        messages: &#123;
            unexpected: &quot;Duplicate case label.&quot;
        &#125;
    &#125;,

    create(context) &#123;
        const sourceCode = context.getSourceCode();

        return &#123;
            SwitchStatement(node) &#123;
                const mapping = &#123;&#125;;

                node.cases.forEach(switchCase =&gt; &#123;
                    const key = sourceCode.getText(switchCase.test);

                    if (mapping[key]) &#123;
                        context.report(&#123; node: switchCase, messageId: &quot;unexpected&quot; &#125;);
                    &#125; else &#123;
                        mapping[key] = switchCase;
                    &#125;
                &#125;);
            &#125;
        &#125;;
    &#125;
&#125;;</code></pre>
<p>代码非常简单，只是初始化时使用一个空的 mapping，每次添加 case 是进行对 mapping 的扩充，如果存在相同的 case 则 report。</p>
<p>虽然 ESLint 背后的技术内容比较复杂，但是基于 AST 技术，它已经给开发者提供了较为成熟的<br>APIs。写一条自己的规则并不是很难，只需要开发者找到相关的 AST 选择器，比如上面代码中的<br>getAllComments()，更多的选择器可以参考：[Selectors - ESLint - Pluggable JavaScript<br>linter](<a target="_blank" rel="noopener" href="https://eslint.org/docs/developer-">https://eslint.org/docs/developer-</a><br>guide/selectors)。熟练掌握选择器，将是我们开发插件扩展的关键。</p>
<p>当然，更复杂的场景远不止这么简单，比如，多条规则是如何串联起来生效的？</p>
<h4 id="多条规则串联生效"><a href="#多条规则串联生效" class="headerlink" title="多条规则串联生效"></a>多条规则串联生效</h4><p>事实上， <strong>规则可以从多个源来定义，比如代码的注释当中，或者配置文件当中。</strong></p>
<p>ESLint 首先收集到所有规则配置源，将所有规则归并之后，进行多重遍历：遍历由源码生成的<br>AST，将语法节点传入队列当中；之后遍历所有应用规则，采用事件发布订阅模式（类似 webpack<br>tapable），为所有规则的选择器添加监听事件；在触发事件时执行，如果发现有问题，会将 report message<br>记录下来。最终记录下来的问题信息将会被输出。</p>
<p>具体 ESLint 的源码如下：</p>
<pre><code>function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename) &#123;
    const emitter = createEmitter();
    const nodeQueue = [];
    let currentNode = sourceCode.ast;

    Traverser.traverse(sourceCode.ast, &#123;
        enter(node, parent) &#123;
            node.parent = parent;
            nodeQueue.push(&#123; isEntering: true, node &#125;);
        &#125;,
        leave(node) &#123;
            nodeQueue.push(&#123; isEntering: false, node &#125;);
        &#125;,
        visitorKeys: sourceCode.visitorKeys
    &#125;);


    const lintingProblems = [];

    Object.keys(configuredRules).forEach(ruleId =&gt; &#123;
        const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);

        if (severity === 0) &#123;
            return;
        &#125;

        const rule = ruleMapper(ruleId);
        const messageIds = rule.meta &amp;&amp; rule.meta.messages;
        let reportTranslator = null;
        const ruleContext = Object.freeze(
            Object.assign(
Object.create(sharedTraversalContext),
                &#123;
                    id: ruleId,
                    options: getRuleOptions(configuredRules[ruleId]),
                    report(...args) &#123;

                        if (reportTranslator === null) &#123;...&#125;
                        const problem = reportTranslator(...args);
                        if (problem.fix &amp;&amp; rule.meta &amp;&amp; !rule.meta.fixable) &#123;
                            throw new Error(&quot;Fixable rules should export a `meta.fixable` property.&quot;);
                        &#125;
                        lintingProblems.push(problem);
                    &#125;
                &#125;
            )
        );

        const ruleListeners = createRuleListeners(rule, ruleContext);

        // add all the selectors from the rule as listeners
        Object.keys(ruleListeners).forEach(selector =&gt; &#123;
            emitter.on();
        &#125;);
    &#125;);

    const eventGenerator = new CodePathAnalyzer(new NodeEventGenerator(emitter));

    nodeQueue.forEach(traversalInfo =&gt; &#123;
        currentNode = traversalInfo.node;
        if (traversalInfo.isEntering) &#123;
            eventGenerator.enterNode(currentNode);
        &#125; else &#123;
            eventGenerator.leaveNode(currentNode);
        &#125;
    &#125;);

    return lintingProblems;
&#125;</code></pre>
<p>请再思考，我们的程序中免不了有各种条件语句、循环语句，因此 <strong>代码的执行是非顺序的</strong> 。相关规则比如：“检测定义但未使用变量”，“switch-case<br>中避免执行多条 case 语句”，这些规则的实现，就涉及 ESLint 更高级的 code path analysis 概念等。ESLint 将 code<br>path 抽象为 5 个事件。</p>
<ul>
<li>onCodePathStart</li>
<li>onCodePathEnd</li>
<li>onCodePathSegmentStart</li>
<li>onCodePathSegmentEnd</li>
<li>onCodePathSegmentLoop</li>
</ul>
<p>利用这 5 个事件，我们可以更加精确地控制检测范围和粒度。更多的 ESLint rule 实现，可以翻看源码进行学习，总之根据这 5<br>种事件，我们可以监测非顺序性代码，其核心原理还是事件机制。</p>
<p>我们通过 no-unreachable 规则来进行了解，该规则可以通过监测 return，throws，break，continue<br>的使用，识别出不会被执行的代码，并 report：</p>
<pre><code>/**
 * Checks whether or not a given variable declarator has the initializer.
 * @param &#123;ASTNode&#125; node - A VariableDeclarator node to check.
 * @returns &#123;boolean&#125; `true` if the node has the initializer.
 */
function isInitialized(node) &#123;
    return Boolean(node.init);
&#125;

/**
 * Checks whether or not a given code path segment is unreachable.
 * @param &#123;CodePathSegment&#125; segment - A CodePathSegment to check.
 * @returns &#123;boolean&#125; `true` if the segment is unreachable.
 */
function isUnreachable(segment) &#123;
    return !segment.reachable;
&#125;

/**
 * The class to distinguish consecutive unreachable statements.
 */
class ConsecutiveRange &#123;
    constructor(sourceCode) &#123;
        this.sourceCode = sourceCode;
        this.startNode = null;
        this.endNode = null;
    &#125;

    /**
     * The location object of this range.
     * @type &#123;Object&#125;
     */
    get location() &#123;
        return &#123;
            start: this.startNode.loc.start,
            end: this.endNode.loc.end
        &#125;;
    &#125;

    /**
     * `true` if this range is empty.
     * @type &#123;boolean&#125;
     */
    get isEmpty() &#123;
        return !(this.startNode &amp;&amp; this.endNode);
    &#125;

    /**
     * Checks whether the given node is inside of this range.
     * @param &#123;ASTNode|Token&#125; node - The node to check.
     * @returns &#123;boolean&#125; `true` if the node is inside of this range.
     */
    contains(node) &#123;
        return (
            node.range[0] &gt;= this.startNode.range[0] &amp;&amp;
            node.range[1] &lt;= this.endNode.range[1]
        );
    &#125;

    /**
     * Checks whether the given node is consecutive to this range.
     * @param &#123;ASTNode&#125; node - The node to check.
     * @returns &#123;boolean&#125; `true` if the node is consecutive to this range.
     */
    isConsecutive(node) &#123;
        return this.contains(this.sourceCode.getTokenBefore(node));
    &#125;

    /**
     * Merges the given node to this range.
     * @param &#123;ASTNode&#125; node - The node to merge.
     * @returns &#123;void&#125;
     */
    merge(node) &#123;
        this.endNode = node;
    &#125;

    /**
     * Resets this range by the given node or null.
     * @param &#123;ASTNode|null&#125; node - The node to reset, or null.
     * @returns &#123;void&#125;
     */
    reset(node) &#123;
        this.startNode = this.endNode = node;
    &#125;
&#125;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = &#123;
    meta: &#123;
        type: &quot;problem&quot;,

        docs: &#123;
            description: &quot;disallow unreachable code after `return`, `throw`, `continue`, and `break` statements&quot;,
            category: &quot;Possible Errors&quot;,
            recommended: true,
            url: &quot;https://eslint.org/docs/rules/no-unreachable&quot;
        &#125;,

        schema: []
    &#125;,

    create(context) &#123;
        let currentCodePath = null;

        const range = new ConsecutiveRange(context.getSourceCode());

        /**
         * Reports a given node if it&#39;s unreachable.
         * @param &#123;ASTNode&#125; node - A statement node to report.
         * @returns &#123;void&#125;
         */
        function reportIfUnreachable(node) &#123;
            let nextNode = null;

            if (node &amp;&amp; currentCodePath.currentSegments.every(isUnreachable)) &#123;

                // Store this statement to distinguish consecutive statements.
                if (range.isEmpty) &#123;
                    range.reset(node);
                    return;
                &#125;

                // Skip if this statement is inside of the current range.
                if (range.contains(node)) &#123;
                    return;
                &#125;

                // Merge if this statement is consecutive to the current range.
                if (range.isConsecutive(node)) &#123;
                    range.merge(node);
                    return;
                &#125;

                nextNode = node;
            &#125;

            /*
             * Report the current range since this statement is reachable or is
             * not consecutive to the current range.
             */
            if (!range.isEmpty) &#123;
                context.report(&#123;
                    message: &quot;Unreachable code.&quot;,
                    loc: range.location,
                    node: range.startNode
                &#125;);
            &#125;

            // Update the current range.
            range.reset(nextNode);
        &#125;

        return &#123;

            // Manages the current code path.
            onCodePathStart(codePath) &#123;
                currentCodePath = codePath;
            &#125;,

            onCodePathEnd() &#123;
                currentCodePath = currentCodePath.upper;
            &#125;,

            // Registers for all statement nodes (excludes FunctionDeclaration).
            BlockStatement: reportIfUnreachable,
            BreakStatement: reportIfUnreachable,
            ClassDeclaration: reportIfUnreachable,
            ContinueStatement: reportIfUnreachable,
            DebuggerStatement: reportIfUnreachable,
            DoWhileStatement: reportIfUnreachable,
            ExpressionStatement: reportIfUnreachable,
            ForInStatement: reportIfUnreachable,
            ForOfStatement: reportIfUnreachable,
            ForStatement: reportIfUnreachable,
            IfStatement: reportIfUnreachable,
            ImportDeclaration: reportIfUnreachable,
            LabeledStatement: reportIfUnreachable,
            ReturnStatement: reportIfUnreachable,
            SwitchStatement: reportIfUnreachable,
            ThrowStatement: reportIfUnreachable,
            TryStatement: reportIfUnreachable,

            VariableDeclaration(node) &#123;
                if (node.kind !== &quot;var&quot; || node.declarations.some(isInitialized)) &#123;
                    reportIfUnreachable(node);
                &#125;
            &#125;,

            WhileStatement: reportIfUnreachable,
            WithStatement: reportIfUnreachable,
            ExportNamedDeclaration: reportIfUnreachable,
            ExportDefaultDeclaration: reportIfUnreachable,
            ExportAllDeclaration: reportIfUnreachable,

            &quot;Program:exit&quot;() &#123;
                reportIfUnreachable();
            &#125;
        &#125;;
    &#125;
&#125;;</code></pre>
<p>实现中，通过 isUnreachable 函数来判别一个 code path 是否无法触及，我提供一些返例帮助大家理解：</p>
<pre><code>function foo() &#123;
    return true;
    console.log(&quot;done&quot;);
&#125;

function bar() &#123;
    throw new Error(&quot;Oops!&quot;);
    console.log(&quot;done&quot;);
&#125;

while(value) &#123;
    break;
    console.log(&quot;done&quot;);
&#125;

throw new Error(&quot;Oops!&quot;);
console.log(&quot;done&quot;);

function baz() &#123;
    if (Math.random() &lt; 0.5) &#123;
        return;
    &#125; else &#123;
        throw new Error();
    &#125;
    console.log(&quot;done&quot;);
&#125;</code></pre>
<p>因为 unreachable 的代码需要放在一个区块当中去理解，单条语句无法去进行判别，因此使用 ConsecutiveRange 类来保留连续代码信息。</p>
<p>最后，这种优秀的插件扩展机制对于设计一个库，尤其是设计一个规范工具来说，是非常值得借鉴的模式。事实上，prettier<br>也会在新的版本中引入插件机制，目前已经在 beta<br>版，感兴趣的读者可以<a target="_blank" rel="noopener" href="https://prettier.io/docs/en/plugins.html#docsNav">尝鲜</a>。</p>
<h3 id="自动化规范与团队建设"><a href="#自动化规范与团队建设" class="headerlink" title="自动化规范与团队建设"></a>自动化规范与团队建设</h3><p>自动化规范还有其他一些细节，比如使用 EditorConfig 来保证编辑器的设置统一，确定在制表符空格或换行方面的一致性，又如使用<br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/@commitlint/config-conventional">commitlint</a><br>并配合 husky，来保证 commit message 的规范：</p>
<pre><code># 安装 commitlint cli 和 conventional config
npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;

# 配置 commitlint
echo &quot;module.exports = &#123;extends: [&#39;@commitlint/config-conventional&#39;]&#125;&quot; &gt; commitlint.config.js</code></pre>
<p>并在 commit-msg 的 git hook 阶段进行检查，在 package.json 中添加：</p>
<pre><code>&#123;
    &quot;husky&quot;: &#123;
        &quot;hooks&quot;: &#123;
            &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;
        &#125;  
    &#125;
&#125;</code></pre>
<p>我们也可以根据团队需求做更多定制化的尝试，比如自动规范化或生产 commit message，有了规范的 commit message<br>之后，就可以提取关键内容，规范化生产 changelog 等。</p>
<p>其他方向上，还可以从团队文档的生产来考虑。举个例子，如果使用 React 开发项目，那么 React<br>组件文档如何规范化生成？如何提高组件使用的效率，减少学习成本？我在<a target="_blank" rel="noopener" href="https://juejin.im/pin/5c45dd09092dcb473721710d">掘金<br>AMA</a> 上做客时，有人便提出了这样的问题。</p>
<blockquote>
<p>我们组内面临着最古老的 React 管理平台重构任务，这次我们想生成关于管理平台的阅读文档（包括常用的样式命名、工具方法、全局组件、复杂 API<br>交互流程等）。</p>
<p>所以我想提出的问题是：面向 React<br>代码的可维护性和可持续发展（不要单个功能每个团队成员都实现一遍，当新成员加入的时候知道有哪些功能能从现在代码中复用，<br>也知道有哪些功能还没有，他可以添加实现进去），业内有哪些工具或 npm 库或开发模式是可以确切能够帮助解决痛点或者改善现状的呢？</p>
</blockquote>
<p><strong>确实，随着项目复杂度的提升，各种组件也“爆炸式”增长。如何让这些组件方便易用，能快速上手，同时不成为负担，又避免重复造轮子现象，良好的组件管理在团队中非常重要。</strong></p>
<p>关于“React 组件管理文档”，简单梳理一下：总得来说，社区在这方面的探索很多，相关方案也各有特色。</p>
<ul>
<li>最知名的一定是 <a target="_blank" rel="noopener" href="https://storybook.js.org/">storybook</a>，它会生成一个静态页面，专门用来展示组件的实际效果以及用法；缺点是业务侵入性较强，且 story 编写成本较高。</li>
<li>我个人很喜欢的是 <a target="_blank" rel="noopener" href="https://github.com/reactjs/react-docgen">react-docgen</a>，比较极客风格，它能够分析并提取 React 组件信息。原理是使用了 recast 和 @babel/parser AST 分析，最终产出一个 JSON 文档。 <a target="_blank" rel="noopener" href="https://github.com/reactjs/react-docgen">https://github.com/reactjs/react-docgen</a> 是它的网页链接，缺点是它较为轻量，缺乏有效的可视化能力。</li>
<li>那么在 react-docgen 之上，我们可以考虑 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-styleguidist">React Styleguidist</a>，这款 React 组件文档生成器，支持丰富的 demo，可能会更符合需求。</li>
<li>一些小而美的解决方案：比如 react-doc、react-doc-generator、cherrypdoc，都可以考虑尝试。</li>
</ul>
<p>“自己动手、丰衣足食”，其实开发一个类似的工具并不会太复杂。如果有时间和精力，你可以根据自己的需求，实现一个完全匹配自己团队的 React<br>组件管理文档，或者其他框架相关、业务相关的文档，这非常有意义。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在规范化的道路上，只有你想不到，没有你做不到。</p>
<p>简单的规范化工具用起来非常清爽，但是背后的实现却蕴含了很深的设计与技术细节，值得我们深入学习。</p>
<p>作为前端工程师，我们应该从平时开发的痛点和效率瓶颈入手，敢于尝试，不断探索。保证团队开发的自动化程度，就能减少不必要的麻烦。</p>
<p>除了“偏硬”的强制规范手段，一些“软方向”，比如团队氛围、code review/analyse<br>等，也直接决定着团队的代码质量。进阶的工程师不仅需要在技术上成长，在团队建设上更需要主动交流。</p>
<p>课程代码仓库： <a target="_blank" rel="noopener" href="https://github.com/HOUCe/lucas-gitchat-courses">https://github.com/HOUCe/lucas-gitchat-courses</a></p>
<h3 id="分享交流"><a href="#分享交流" class="headerlink" title="分享交流"></a>分享交流</h3><p>请大家留言分享「代码规范」相关的个人经验心得。阅读文章过程中有任何疑问随时可以跟其他小伙伴讨论，或者直接向作者 LucasHC<br>提问（作者看到后会抽空解答）。 <strong>你的分享不仅帮助他人，更会提升自己。</strong></p>
<p>同时，欢迎说说自己最想了解的主题，课程内容会根据大家的意见和建议迭代和完善。</p>
<blockquote>
<p><strong>为了方便与作者交流与学习，GitChat 编辑团队组织了一个《前端开发核心知识进阶》读者交流群，添加小姐姐-<br>泰勒微信：「GitChatty5」，回复关键字「105」给小姐姐获取入群资格。</strong></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小川</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/031--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/">https://jinxiaochuan.github.io/matrix/2020/12/22/advanced/031--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinxiaochuan.github.io/matrix" target="_blank">Matrix</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/matrix/2020/12/22/advanced/028--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="prev-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">核心进阶28 | 前端工程化背后的项目组织设计（上）</div></div></a></div><div class="next-post pull-right"><a href="/matrix/2020/12/22/advanced/032--%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86%E4%B8%8E%E4%B8%8A%E6%8A%A5%EF%BC%88%E4%B8%8A%EF%BC%89/"><img class="next-cover" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="onerror=null;src='/matrix/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">核心进阶32 | 性能监控和错误收集与上报（上）</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/matrix/null" onerror="this.onerror=null;this.src='/matrix/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">小川</div><div class="author-info__description">前端攻城狮</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/matrix/archives/"><div class="headline">文章</div><div class="length-num">53</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E8%83%8C%E5%90%8E%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%92%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.</span> <span class="toc-text">工具背后的技术原理和设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%9D%A1%E8%A7%84%E5%88%99%E4%B8%B2%E8%81%94%E7%94%9F%E6%95%88"><span class="toc-number">1.1.</span> <span class="toc-text">多条规则串联生效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A7%84%E8%8C%83%E4%B8%8E%E5%9B%A2%E9%98%9F%E5%BB%BA%E8%AE%BE"><span class="toc-number">2.</span> <span class="toc-text">自动化规范与团队建设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E4%BA%AB%E4%BA%A4%E6%B5%81"><span class="toc-number">4.</span> <span class="toc-text">分享交流</span></a></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="01 | 项目基石：前端脚手架工具探秘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/engineering/01/" title="01 | 项目基石：前端脚手架工具探秘">01 | 项目基石：前端脚手架工具探秘</a><time datetime="2020-12-22T12:51:17.448Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="FE Algorithm - 阶乘"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/algorithm/" title="FE Algorithm - 阶乘">FE Algorithm - 阶乘</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/025--%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%88%E5%90%AB%20tree%20shaking%EF%BC%89%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶25 | 深入浅出模块化（含 tree shaking）（下）">核心进阶25 | 深入浅出模块化（含 tree shaking）（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶29 | 前端工程化背后的项目组织设计（下）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/029--%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E8%83%8C%E5%90%8E%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8B%EF%BC%89/" title="核心进阶29 | 前端工程化背后的项目组织设计（下）">核心进阶29 | 前端工程化背后的项目组织设计（下）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/matrix/img/404.jpg'" alt="核心进阶30 | 代码规范工具及背后技术设计（上）"/></a><div class="content"><a class="title" href="/matrix/2020/12/22/advanced/030--%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%B7%A5%E5%85%B7%E5%8F%8A%E8%83%8C%E5%90%8E%E6%8A%80%E6%9C%AF%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="核心进阶30 | 代码规范工具及背后技术设计（上）">核心进阶30 | 代码规范工具及背后技术设计（上）</a><time datetime="2020-12-22T12:51:17.444Z" title="发表于 2020-12-22 20:51:17">2020-12-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 By 小川</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/matrix/js/utils.js"></script><script src="/matrix/js/main.js"></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>